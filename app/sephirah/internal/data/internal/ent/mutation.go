// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/account"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/app"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/apppackage"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/apppackageruntime"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/deviceinfo"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feed"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feedconfig"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feeditem"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/file"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/image"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflow"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflowsource"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflowtarget"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifytarget"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/porterinstance"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/porterprivilege"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/predicate"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/user"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/usersession"
	"github.com/tuihub/librarian/app/sephirah/internal/model/modeltiphereth"
	"github.com/tuihub/librarian/internal/model"
	"github.com/tuihub/librarian/internal/model/modelfeed"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount           = "Account"
	TypeApp               = "App"
	TypeAppPackage        = "AppPackage"
	TypeAppPackageRunTime = "AppPackageRunTime"
	TypeDeviceInfo        = "DeviceInfo"
	TypeFeed              = "Feed"
	TypeFeedConfig        = "FeedConfig"
	TypeFeedItem          = "FeedItem"
	TypeFile              = "File"
	TypeImage             = "Image"
	TypeNotifyFlow        = "NotifyFlow"
	TypeNotifyFlowSource  = "NotifyFlowSource"
	TypeNotifyFlowTarget  = "NotifyFlowTarget"
	TypeNotifyTarget      = "NotifyTarget"
	TypePorterInstance    = "PorterInstance"
	TypePorterPrivilege   = "PorterPrivilege"
	TypeUser              = "User"
	TypeUserSession       = "UserSession"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	platform             *string
	platform_account_id  *string
	name                 *string
	profile_url          *string
	avatar_url           *string
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	purchased_app        map[model.InternalID]struct{}
	removedpurchased_app map[model.InternalID]struct{}
	clearedpurchased_app bool
	bind_user            *model.InternalID
	clearedbind_user     bool
	done                 bool
	oldValue             func(context.Context) (*Account, error)
	predicates           []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id model.InternalID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *AccountMutation) SetPlatformAccountID(s string) {
	m.platform_account_id = &s
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *AccountMutation) PlatformAccountID() (r string, exists bool) {
	v := m.platform_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatformAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *AccountMutation) ResetPlatformAccountID() {
	m.platform_account_id = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetProfileURL sets the "profile_url" field.
func (m *AccountMutation) SetProfileURL(s string) {
	m.profile_url = &s
}

// ProfileURL returns the value of the "profile_url" field in the mutation.
func (m *AccountMutation) ProfileURL() (r string, exists bool) {
	v := m.profile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileURL returns the old "profile_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileURL: %w", err)
	}
	return oldValue.ProfileURL, nil
}

// ResetProfileURL resets all changes to the "profile_url" field.
func (m *AccountMutation) ResetProfileURL() {
	m.profile_url = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *AccountMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *AccountMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *AccountMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPurchasedAppIDs adds the "purchased_app" edge to the App entity by ids.
func (m *AccountMutation) AddPurchasedAppIDs(ids ...model.InternalID) {
	if m.purchased_app == nil {
		m.purchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_app[ids[i]] = struct{}{}
	}
}

// ClearPurchasedApp clears the "purchased_app" edge to the App entity.
func (m *AccountMutation) ClearPurchasedApp() {
	m.clearedpurchased_app = true
}

// PurchasedAppCleared reports if the "purchased_app" edge to the App entity was cleared.
func (m *AccountMutation) PurchasedAppCleared() bool {
	return m.clearedpurchased_app
}

// RemovePurchasedAppIDs removes the "purchased_app" edge to the App entity by IDs.
func (m *AccountMutation) RemovePurchasedAppIDs(ids ...model.InternalID) {
	if m.removedpurchased_app == nil {
		m.removedpurchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_app, ids[i])
		m.removedpurchased_app[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedApp returns the removed IDs of the "purchased_app" edge to the App entity.
func (m *AccountMutation) RemovedPurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_app {
		ids = append(ids, id)
	}
	return
}

// PurchasedAppIDs returns the "purchased_app" edge IDs in the mutation.
func (m *AccountMutation) PurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.purchased_app {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedApp resets all changes to the "purchased_app" edge.
func (m *AccountMutation) ResetPurchasedApp() {
	m.purchased_app = nil
	m.clearedpurchased_app = false
	m.removedpurchased_app = nil
}

// SetBindUserID sets the "bind_user" edge to the User entity by id.
func (m *AccountMutation) SetBindUserID(id model.InternalID) {
	m.bind_user = &id
}

// ClearBindUser clears the "bind_user" edge to the User entity.
func (m *AccountMutation) ClearBindUser() {
	m.clearedbind_user = true
}

// BindUserCleared reports if the "bind_user" edge to the User entity was cleared.
func (m *AccountMutation) BindUserCleared() bool {
	return m.clearedbind_user
}

// BindUserID returns the "bind_user" edge ID in the mutation.
func (m *AccountMutation) BindUserID() (id model.InternalID, exists bool) {
	if m.bind_user != nil {
		return *m.bind_user, true
	}
	return
}

// BindUserIDs returns the "bind_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BindUserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) BindUserIDs() (ids []model.InternalID) {
	if id := m.bind_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBindUser resets all changes to the "bind_user" edge.
func (m *AccountMutation) ResetBindUser() {
	m.bind_user = nil
	m.clearedbind_user = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m.platform_account_id != nil {
		fields = append(fields, account.FieldPlatformAccountID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.profile_url != nil {
		fields = append(fields, account.FieldProfileURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, account.FieldAvatarURL)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case account.FieldName:
		return m.Name()
	case account.FieldProfileURL:
		return m.ProfileURL()
	case account.FieldAvatarURL:
		return m.AvatarURL()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldProfileURL:
		return m.OldProfileURL(ctx)
	case account.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldPlatformAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldProfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileURL(v)
		return nil
	case account.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldProfileURL:
		m.ResetProfileURL()
		return nil
	case account.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.purchased_app != nil {
		edges = append(edges, account.EdgePurchasedApp)
	}
	if m.bind_user != nil {
		edges = append(edges, account.EdgeBindUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.purchased_app))
		for id := range m.purchased_app {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeBindUser:
		if id := m.bind_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpurchased_app != nil {
		edges = append(edges, account.EdgePurchasedApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.removedpurchased_app))
		for id := range m.removedpurchased_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpurchased_app {
		edges = append(edges, account.EdgePurchasedApp)
	}
	if m.clearedbind_user {
		edges = append(edges, account.EdgeBindUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgePurchasedApp:
		return m.clearedpurchased_app
	case account.EdgeBindUser:
		return m.clearedbind_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeBindUser:
		m.ClearBindUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgePurchasedApp:
		m.ResetPurchasedApp()
		return nil
	case account.EdgeBindUser:
		m.ResetBindUser()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	internal                    *bool
	source                      *string
	source_app_id               *string
	source_url                  *string
	name                        *string
	_type                       *app.Type
	short_description           *string
	description                 *string
	icon_image_url              *string
	background_image_url        *string
	cover_image_url             *string
	release_date                *string
	developer                   *string
	publisher                   *string
	version                     *string
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	purchased_by_account        map[model.InternalID]struct{}
	removedpurchased_by_account map[model.InternalID]struct{}
	clearedpurchased_by_account bool
	purchased_by_user           map[model.InternalID]struct{}
	removedpurchased_by_user    map[model.InternalID]struct{}
	clearedpurchased_by_user    bool
	app_package                 map[model.InternalID]struct{}
	removedapp_package          map[model.InternalID]struct{}
	clearedapp_package          bool
	bind_internal               *model.InternalID
	clearedbind_internal        bool
	bind_external               map[model.InternalID]struct{}
	removedbind_external        map[model.InternalID]struct{}
	clearedbind_external        bool
	done                        bool
	oldValue                    func(context.Context) (*App, error)
	predicates                  []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id model.InternalID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternal sets the "internal" field.
func (m *AppMutation) SetInternal(b bool) {
	m.internal = &b
}

// Internal returns the value of the "internal" field in the mutation.
func (m *AppMutation) Internal() (r bool, exists bool) {
	v := m.internal
	if v == nil {
		return
	}
	return *v, true
}

// OldInternal returns the old "internal" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldInternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternal: %w", err)
	}
	return oldValue.Internal, nil
}

// ResetInternal resets all changes to the "internal" field.
func (m *AppMutation) ResetInternal() {
	m.internal = nil
}

// SetSource sets the "source" field.
func (m *AppMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AppMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AppMutation) ResetSource() {
	m.source = nil
}

// SetSourceAppID sets the "source_app_id" field.
func (m *AppMutation) SetSourceAppID(s string) {
	m.source_app_id = &s
}

// SourceAppID returns the value of the "source_app_id" field in the mutation.
func (m *AppMutation) SourceAppID() (r string, exists bool) {
	v := m.source_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAppID returns the old "source_app_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSourceAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAppID: %w", err)
	}
	return oldValue.SourceAppID, nil
}

// ResetSourceAppID resets all changes to the "source_app_id" field.
func (m *AppMutation) ResetSourceAppID() {
	m.source_app_id = nil
}

// SetSourceURL sets the "source_url" field.
func (m *AppMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *AppMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ClearSourceURL clears the value of the "source_url" field.
func (m *AppMutation) ClearSourceURL() {
	m.source_url = nil
	m.clearedFields[app.FieldSourceURL] = struct{}{}
}

// SourceURLCleared returns if the "source_url" field was cleared in this mutation.
func (m *AppMutation) SourceURLCleared() bool {
	_, ok := m.clearedFields[app.FieldSourceURL]
	return ok
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *AppMutation) ResetSourceURL() {
	m.source_url = nil
	delete(m.clearedFields, app.FieldSourceURL)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(a app.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r app.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v app.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetShortDescription sets the "short_description" field.
func (m *AppMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *AppMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *AppMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[app.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *AppMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *AppMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, app.FieldShortDescription)
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[app.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, app.FieldDescription)
}

// SetIconImageURL sets the "icon_image_url" field.
func (m *AppMutation) SetIconImageURL(s string) {
	m.icon_image_url = &s
}

// IconImageURL returns the value of the "icon_image_url" field in the mutation.
func (m *AppMutation) IconImageURL() (r string, exists bool) {
	v := m.icon_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageURL returns the old "icon_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIconImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageURL: %w", err)
	}
	return oldValue.IconImageURL, nil
}

// ClearIconImageURL clears the value of the "icon_image_url" field.
func (m *AppMutation) ClearIconImageURL() {
	m.icon_image_url = nil
	m.clearedFields[app.FieldIconImageURL] = struct{}{}
}

// IconImageURLCleared returns if the "icon_image_url" field was cleared in this mutation.
func (m *AppMutation) IconImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldIconImageURL]
	return ok
}

// ResetIconImageURL resets all changes to the "icon_image_url" field.
func (m *AppMutation) ResetIconImageURL() {
	m.icon_image_url = nil
	delete(m.clearedFields, app.FieldIconImageURL)
}

// SetBackgroundImageURL sets the "background_image_url" field.
func (m *AppMutation) SetBackgroundImageURL(s string) {
	m.background_image_url = &s
}

// BackgroundImageURL returns the value of the "background_image_url" field in the mutation.
func (m *AppMutation) BackgroundImageURL() (r string, exists bool) {
	v := m.background_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageURL returns the old "background_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldBackgroundImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageURL: %w", err)
	}
	return oldValue.BackgroundImageURL, nil
}

// ClearBackgroundImageURL clears the value of the "background_image_url" field.
func (m *AppMutation) ClearBackgroundImageURL() {
	m.background_image_url = nil
	m.clearedFields[app.FieldBackgroundImageURL] = struct{}{}
}

// BackgroundImageURLCleared returns if the "background_image_url" field was cleared in this mutation.
func (m *AppMutation) BackgroundImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldBackgroundImageURL]
	return ok
}

// ResetBackgroundImageURL resets all changes to the "background_image_url" field.
func (m *AppMutation) ResetBackgroundImageURL() {
	m.background_image_url = nil
	delete(m.clearedFields, app.FieldBackgroundImageURL)
}

// SetCoverImageURL sets the "cover_image_url" field.
func (m *AppMutation) SetCoverImageURL(s string) {
	m.cover_image_url = &s
}

// CoverImageURL returns the value of the "cover_image_url" field in the mutation.
func (m *AppMutation) CoverImageURL() (r string, exists bool) {
	v := m.cover_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageURL returns the old "cover_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCoverImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageURL: %w", err)
	}
	return oldValue.CoverImageURL, nil
}

// ClearCoverImageURL clears the value of the "cover_image_url" field.
func (m *AppMutation) ClearCoverImageURL() {
	m.cover_image_url = nil
	m.clearedFields[app.FieldCoverImageURL] = struct{}{}
}

// CoverImageURLCleared returns if the "cover_image_url" field was cleared in this mutation.
func (m *AppMutation) CoverImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldCoverImageURL]
	return ok
}

// ResetCoverImageURL resets all changes to the "cover_image_url" field.
func (m *AppMutation) ResetCoverImageURL() {
	m.cover_image_url = nil
	delete(m.clearedFields, app.FieldCoverImageURL)
}

// SetReleaseDate sets the "release_date" field.
func (m *AppMutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *AppMutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *AppMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[app.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *AppMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[app.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *AppMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, app.FieldReleaseDate)
}

// SetDeveloper sets the "developer" field.
func (m *AppMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *AppMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *AppMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[app.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *AppMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[app.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *AppMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, app.FieldDeveloper)
}

// SetPublisher sets the "publisher" field.
func (m *AppMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[app.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[app.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, app.FieldPublisher)
}

// SetVersion sets the "version" field.
func (m *AppMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *AppMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[app.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *AppMutation) VersionCleared() bool {
	_, ok := m.clearedFields[app.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *AppMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, app.FieldVersion)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPurchasedByAccountIDs adds the "purchased_by_account" edge to the Account entity by ids.
func (m *AppMutation) AddPurchasedByAccountIDs(ids ...model.InternalID) {
	if m.purchased_by_account == nil {
		m.purchased_by_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_by_account[ids[i]] = struct{}{}
	}
}

// ClearPurchasedByAccount clears the "purchased_by_account" edge to the Account entity.
func (m *AppMutation) ClearPurchasedByAccount() {
	m.clearedpurchased_by_account = true
}

// PurchasedByAccountCleared reports if the "purchased_by_account" edge to the Account entity was cleared.
func (m *AppMutation) PurchasedByAccountCleared() bool {
	return m.clearedpurchased_by_account
}

// RemovePurchasedByAccountIDs removes the "purchased_by_account" edge to the Account entity by IDs.
func (m *AppMutation) RemovePurchasedByAccountIDs(ids ...model.InternalID) {
	if m.removedpurchased_by_account == nil {
		m.removedpurchased_by_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_by_account, ids[i])
		m.removedpurchased_by_account[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedByAccount returns the removed IDs of the "purchased_by_account" edge to the Account entity.
func (m *AppMutation) RemovedPurchasedByAccountIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_by_account {
		ids = append(ids, id)
	}
	return
}

// PurchasedByAccountIDs returns the "purchased_by_account" edge IDs in the mutation.
func (m *AppMutation) PurchasedByAccountIDs() (ids []model.InternalID) {
	for id := range m.purchased_by_account {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedByAccount resets all changes to the "purchased_by_account" edge.
func (m *AppMutation) ResetPurchasedByAccount() {
	m.purchased_by_account = nil
	m.clearedpurchased_by_account = false
	m.removedpurchased_by_account = nil
}

// AddPurchasedByUserIDs adds the "purchased_by_user" edge to the User entity by ids.
func (m *AppMutation) AddPurchasedByUserIDs(ids ...model.InternalID) {
	if m.purchased_by_user == nil {
		m.purchased_by_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_by_user[ids[i]] = struct{}{}
	}
}

// ClearPurchasedByUser clears the "purchased_by_user" edge to the User entity.
func (m *AppMutation) ClearPurchasedByUser() {
	m.clearedpurchased_by_user = true
}

// PurchasedByUserCleared reports if the "purchased_by_user" edge to the User entity was cleared.
func (m *AppMutation) PurchasedByUserCleared() bool {
	return m.clearedpurchased_by_user
}

// RemovePurchasedByUserIDs removes the "purchased_by_user" edge to the User entity by IDs.
func (m *AppMutation) RemovePurchasedByUserIDs(ids ...model.InternalID) {
	if m.removedpurchased_by_user == nil {
		m.removedpurchased_by_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_by_user, ids[i])
		m.removedpurchased_by_user[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedByUser returns the removed IDs of the "purchased_by_user" edge to the User entity.
func (m *AppMutation) RemovedPurchasedByUserIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_by_user {
		ids = append(ids, id)
	}
	return
}

// PurchasedByUserIDs returns the "purchased_by_user" edge IDs in the mutation.
func (m *AppMutation) PurchasedByUserIDs() (ids []model.InternalID) {
	for id := range m.purchased_by_user {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedByUser resets all changes to the "purchased_by_user" edge.
func (m *AppMutation) ResetPurchasedByUser() {
	m.purchased_by_user = nil
	m.clearedpurchased_by_user = false
	m.removedpurchased_by_user = nil
}

// AddAppPackageIDs adds the "app_package" edge to the AppPackage entity by ids.
func (m *AppMutation) AddAppPackageIDs(ids ...model.InternalID) {
	if m.app_package == nil {
		m.app_package = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_package[ids[i]] = struct{}{}
	}
}

// ClearAppPackage clears the "app_package" edge to the AppPackage entity.
func (m *AppMutation) ClearAppPackage() {
	m.clearedapp_package = true
}

// AppPackageCleared reports if the "app_package" edge to the AppPackage entity was cleared.
func (m *AppMutation) AppPackageCleared() bool {
	return m.clearedapp_package
}

// RemoveAppPackageIDs removes the "app_package" edge to the AppPackage entity by IDs.
func (m *AppMutation) RemoveAppPackageIDs(ids ...model.InternalID) {
	if m.removedapp_package == nil {
		m.removedapp_package = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_package, ids[i])
		m.removedapp_package[ids[i]] = struct{}{}
	}
}

// RemovedAppPackage returns the removed IDs of the "app_package" edge to the AppPackage entity.
func (m *AppMutation) RemovedAppPackageIDs() (ids []model.InternalID) {
	for id := range m.removedapp_package {
		ids = append(ids, id)
	}
	return
}

// AppPackageIDs returns the "app_package" edge IDs in the mutation.
func (m *AppMutation) AppPackageIDs() (ids []model.InternalID) {
	for id := range m.app_package {
		ids = append(ids, id)
	}
	return
}

// ResetAppPackage resets all changes to the "app_package" edge.
func (m *AppMutation) ResetAppPackage() {
	m.app_package = nil
	m.clearedapp_package = false
	m.removedapp_package = nil
}

// SetBindInternalID sets the "bind_internal" edge to the App entity by id.
func (m *AppMutation) SetBindInternalID(id model.InternalID) {
	m.bind_internal = &id
}

// ClearBindInternal clears the "bind_internal" edge to the App entity.
func (m *AppMutation) ClearBindInternal() {
	m.clearedbind_internal = true
}

// BindInternalCleared reports if the "bind_internal" edge to the App entity was cleared.
func (m *AppMutation) BindInternalCleared() bool {
	return m.clearedbind_internal
}

// BindInternalID returns the "bind_internal" edge ID in the mutation.
func (m *AppMutation) BindInternalID() (id model.InternalID, exists bool) {
	if m.bind_internal != nil {
		return *m.bind_internal, true
	}
	return
}

// BindInternalIDs returns the "bind_internal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BindInternalID instead. It exists only for internal usage by the builders.
func (m *AppMutation) BindInternalIDs() (ids []model.InternalID) {
	if id := m.bind_internal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBindInternal resets all changes to the "bind_internal" edge.
func (m *AppMutation) ResetBindInternal() {
	m.bind_internal = nil
	m.clearedbind_internal = false
}

// AddBindExternalIDs adds the "bind_external" edge to the App entity by ids.
func (m *AppMutation) AddBindExternalIDs(ids ...model.InternalID) {
	if m.bind_external == nil {
		m.bind_external = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.bind_external[ids[i]] = struct{}{}
	}
}

// ClearBindExternal clears the "bind_external" edge to the App entity.
func (m *AppMutation) ClearBindExternal() {
	m.clearedbind_external = true
}

// BindExternalCleared reports if the "bind_external" edge to the App entity was cleared.
func (m *AppMutation) BindExternalCleared() bool {
	return m.clearedbind_external
}

// RemoveBindExternalIDs removes the "bind_external" edge to the App entity by IDs.
func (m *AppMutation) RemoveBindExternalIDs(ids ...model.InternalID) {
	if m.removedbind_external == nil {
		m.removedbind_external = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.bind_external, ids[i])
		m.removedbind_external[ids[i]] = struct{}{}
	}
}

// RemovedBindExternal returns the removed IDs of the "bind_external" edge to the App entity.
func (m *AppMutation) RemovedBindExternalIDs() (ids []model.InternalID) {
	for id := range m.removedbind_external {
		ids = append(ids, id)
	}
	return
}

// BindExternalIDs returns the "bind_external" edge IDs in the mutation.
func (m *AppMutation) BindExternalIDs() (ids []model.InternalID) {
	for id := range m.bind_external {
		ids = append(ids, id)
	}
	return
}

// ResetBindExternal resets all changes to the "bind_external" edge.
func (m *AppMutation) ResetBindExternal() {
	m.bind_external = nil
	m.clearedbind_external = false
	m.removedbind_external = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.internal != nil {
		fields = append(fields, app.FieldInternal)
	}
	if m.source != nil {
		fields = append(fields, app.FieldSource)
	}
	if m.source_app_id != nil {
		fields = append(fields, app.FieldSourceAppID)
	}
	if m.source_url != nil {
		fields = append(fields, app.FieldSourceURL)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m._type != nil {
		fields = append(fields, app.FieldType)
	}
	if m.short_description != nil {
		fields = append(fields, app.FieldShortDescription)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.icon_image_url != nil {
		fields = append(fields, app.FieldIconImageURL)
	}
	if m.background_image_url != nil {
		fields = append(fields, app.FieldBackgroundImageURL)
	}
	if m.cover_image_url != nil {
		fields = append(fields, app.FieldCoverImageURL)
	}
	if m.release_date != nil {
		fields = append(fields, app.FieldReleaseDate)
	}
	if m.developer != nil {
		fields = append(fields, app.FieldDeveloper)
	}
	if m.publisher != nil {
		fields = append(fields, app.FieldPublisher)
	}
	if m.version != nil {
		fields = append(fields, app.FieldVersion)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldInternal:
		return m.Internal()
	case app.FieldSource:
		return m.Source()
	case app.FieldSourceAppID:
		return m.SourceAppID()
	case app.FieldSourceURL:
		return m.SourceURL()
	case app.FieldName:
		return m.Name()
	case app.FieldType:
		return m.GetType()
	case app.FieldShortDescription:
		return m.ShortDescription()
	case app.FieldDescription:
		return m.Description()
	case app.FieldIconImageURL:
		return m.IconImageURL()
	case app.FieldBackgroundImageURL:
		return m.BackgroundImageURL()
	case app.FieldCoverImageURL:
		return m.CoverImageURL()
	case app.FieldReleaseDate:
		return m.ReleaseDate()
	case app.FieldDeveloper:
		return m.Developer()
	case app.FieldPublisher:
		return m.Publisher()
	case app.FieldVersion:
		return m.Version()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldInternal:
		return m.OldInternal(ctx)
	case app.FieldSource:
		return m.OldSource(ctx)
	case app.FieldSourceAppID:
		return m.OldSourceAppID(ctx)
	case app.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldType:
		return m.OldType(ctx)
	case app.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldIconImageURL:
		return m.OldIconImageURL(ctx)
	case app.FieldBackgroundImageURL:
		return m.OldBackgroundImageURL(ctx)
	case app.FieldCoverImageURL:
		return m.OldCoverImageURL(ctx)
	case app.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case app.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case app.FieldPublisher:
		return m.OldPublisher(ctx)
	case app.FieldVersion:
		return m.OldVersion(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldInternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternal(v)
		return nil
	case app.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case app.FieldSourceAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAppID(v)
		return nil
	case app.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldType:
		v, ok := value.(app.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case app.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldIconImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageURL(v)
		return nil
	case app.FieldBackgroundImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageURL(v)
		return nil
	case app.FieldCoverImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageURL(v)
		return nil
	case app.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case app.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case app.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case app.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldSourceURL) {
		fields = append(fields, app.FieldSourceURL)
	}
	if m.FieldCleared(app.FieldShortDescription) {
		fields = append(fields, app.FieldShortDescription)
	}
	if m.FieldCleared(app.FieldDescription) {
		fields = append(fields, app.FieldDescription)
	}
	if m.FieldCleared(app.FieldIconImageURL) {
		fields = append(fields, app.FieldIconImageURL)
	}
	if m.FieldCleared(app.FieldBackgroundImageURL) {
		fields = append(fields, app.FieldBackgroundImageURL)
	}
	if m.FieldCleared(app.FieldCoverImageURL) {
		fields = append(fields, app.FieldCoverImageURL)
	}
	if m.FieldCleared(app.FieldReleaseDate) {
		fields = append(fields, app.FieldReleaseDate)
	}
	if m.FieldCleared(app.FieldDeveloper) {
		fields = append(fields, app.FieldDeveloper)
	}
	if m.FieldCleared(app.FieldPublisher) {
		fields = append(fields, app.FieldPublisher)
	}
	if m.FieldCleared(app.FieldVersion) {
		fields = append(fields, app.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldSourceURL:
		m.ClearSourceURL()
		return nil
	case app.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case app.FieldDescription:
		m.ClearDescription()
		return nil
	case app.FieldIconImageURL:
		m.ClearIconImageURL()
		return nil
	case app.FieldBackgroundImageURL:
		m.ClearBackgroundImageURL()
		return nil
	case app.FieldCoverImageURL:
		m.ClearCoverImageURL()
		return nil
	case app.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case app.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case app.FieldPublisher:
		m.ClearPublisher()
		return nil
	case app.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldInternal:
		m.ResetInternal()
		return nil
	case app.FieldSource:
		m.ResetSource()
		return nil
	case app.FieldSourceAppID:
		m.ResetSourceAppID()
		return nil
	case app.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldType:
		m.ResetType()
		return nil
	case app.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldIconImageURL:
		m.ResetIconImageURL()
		return nil
	case app.FieldBackgroundImageURL:
		m.ResetBackgroundImageURL()
		return nil
	case app.FieldCoverImageURL:
		m.ResetCoverImageURL()
		return nil
	case app.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case app.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case app.FieldPublisher:
		m.ResetPublisher()
		return nil
	case app.FieldVersion:
		m.ResetVersion()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.purchased_by_account != nil {
		edges = append(edges, app.EdgePurchasedByAccount)
	}
	if m.purchased_by_user != nil {
		edges = append(edges, app.EdgePurchasedByUser)
	}
	if m.app_package != nil {
		edges = append(edges, app.EdgeAppPackage)
	}
	if m.bind_internal != nil {
		edges = append(edges, app.EdgeBindInternal)
	}
	if m.bind_external != nil {
		edges = append(edges, app.EdgeBindExternal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgePurchasedByAccount:
		ids := make([]ent.Value, 0, len(m.purchased_by_account))
		for id := range m.purchased_by_account {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePurchasedByUser:
		ids := make([]ent.Value, 0, len(m.purchased_by_user))
		for id := range m.purchased_by_user {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppPackage:
		ids := make([]ent.Value, 0, len(m.app_package))
		for id := range m.app_package {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBindInternal:
		if id := m.bind_internal; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeBindExternal:
		ids := make([]ent.Value, 0, len(m.bind_external))
		for id := range m.bind_external {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpurchased_by_account != nil {
		edges = append(edges, app.EdgePurchasedByAccount)
	}
	if m.removedpurchased_by_user != nil {
		edges = append(edges, app.EdgePurchasedByUser)
	}
	if m.removedapp_package != nil {
		edges = append(edges, app.EdgeAppPackage)
	}
	if m.removedbind_external != nil {
		edges = append(edges, app.EdgeBindExternal)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgePurchasedByAccount:
		ids := make([]ent.Value, 0, len(m.removedpurchased_by_account))
		for id := range m.removedpurchased_by_account {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePurchasedByUser:
		ids := make([]ent.Value, 0, len(m.removedpurchased_by_user))
		for id := range m.removedpurchased_by_user {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppPackage:
		ids := make([]ent.Value, 0, len(m.removedapp_package))
		for id := range m.removedapp_package {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBindExternal:
		ids := make([]ent.Value, 0, len(m.removedbind_external))
		for id := range m.removedbind_external {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpurchased_by_account {
		edges = append(edges, app.EdgePurchasedByAccount)
	}
	if m.clearedpurchased_by_user {
		edges = append(edges, app.EdgePurchasedByUser)
	}
	if m.clearedapp_package {
		edges = append(edges, app.EdgeAppPackage)
	}
	if m.clearedbind_internal {
		edges = append(edges, app.EdgeBindInternal)
	}
	if m.clearedbind_external {
		edges = append(edges, app.EdgeBindExternal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgePurchasedByAccount:
		return m.clearedpurchased_by_account
	case app.EdgePurchasedByUser:
		return m.clearedpurchased_by_user
	case app.EdgeAppPackage:
		return m.clearedapp_package
	case app.EdgeBindInternal:
		return m.clearedbind_internal
	case app.EdgeBindExternal:
		return m.clearedbind_external
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeBindInternal:
		m.ClearBindInternal()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgePurchasedByAccount:
		m.ResetPurchasedByAccount()
		return nil
	case app.EdgePurchasedByUser:
		m.ResetPurchasedByUser()
		return nil
	case app.EdgeAppPackage:
		m.ResetAppPackage()
		return nil
	case app.EdgeBindInternal:
		m.ResetBindInternal()
		return nil
	case app.EdgeBindExternal:
		m.ResetBindExternal()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppPackageMutation represents an operation that mutates the AppPackage nodes in the graph.
type AppPackageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	source               *apppackage.Source
	source_id            *model.InternalID
	addsource_id         *model.InternalID
	name                 *string
	description          *string
	public               *bool
	binary_name          *string
	binary_size_bytes    *int64
	addbinary_size_bytes *int64
	binary_public_url    *string
	binary_sha256        *[]byte
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	owner                *model.InternalID
	clearedowner         bool
	app                  *model.InternalID
	clearedapp           bool
	done                 bool
	oldValue             func(context.Context) (*AppPackage, error)
	predicates           []predicate.AppPackage
}

var _ ent.Mutation = (*AppPackageMutation)(nil)

// apppackageOption allows management of the mutation configuration using functional options.
type apppackageOption func(*AppPackageMutation)

// newAppPackageMutation creates new mutation for the AppPackage entity.
func newAppPackageMutation(c config, op Op, opts ...apppackageOption) *AppPackageMutation {
	m := &AppPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPackageID sets the ID field of the mutation.
func withAppPackageID(id model.InternalID) apppackageOption {
	return func(m *AppPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPackage
		)
		m.oldValue = func(ctx context.Context) (*AppPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPackage sets the old AppPackage of the mutation.
func withAppPackage(node *AppPackage) apppackageOption {
	return func(m *AppPackageMutation) {
		m.oldValue = func(context.Context) (*AppPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPackage entities.
func (m *AppPackageMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPackageMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPackageMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSource sets the "source" field.
func (m *AppPackageMutation) SetSource(a apppackage.Source) {
	m.source = &a
}

// Source returns the value of the "source" field in the mutation.
func (m *AppPackageMutation) Source() (r apppackage.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldSource(ctx context.Context) (v apppackage.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AppPackageMutation) ResetSource() {
	m.source = nil
}

// SetSourceID sets the "source_id" field.
func (m *AppPackageMutation) SetSourceID(mi model.InternalID) {
	m.source_id = &mi
	m.addsource_id = nil
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *AppPackageMutation) SourceID() (r model.InternalID, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldSourceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// AddSourceID adds mi to the "source_id" field.
func (m *AppPackageMutation) AddSourceID(mi model.InternalID) {
	if m.addsource_id != nil {
		*m.addsource_id += mi
	} else {
		m.addsource_id = &mi
	}
}

// AddedSourceID returns the value that was added to the "source_id" field in this mutation.
func (m *AppPackageMutation) AddedSourceID() (r model.InternalID, exists bool) {
	v := m.addsource_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *AppPackageMutation) ResetSourceID() {
	m.source_id = nil
	m.addsource_id = nil
}

// SetName sets the "name" field.
func (m *AppPackageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppPackageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppPackageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AppPackageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppPackageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppPackageMutation) ResetDescription() {
	m.description = nil
}

// SetPublic sets the "public" field.
func (m *AppPackageMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *AppPackageMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *AppPackageMutation) ResetPublic() {
	m.public = nil
}

// SetBinaryName sets the "binary_name" field.
func (m *AppPackageMutation) SetBinaryName(s string) {
	m.binary_name = &s
}

// BinaryName returns the value of the "binary_name" field in the mutation.
func (m *AppPackageMutation) BinaryName() (r string, exists bool) {
	v := m.binary_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryName returns the old "binary_name" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldBinaryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryName: %w", err)
	}
	return oldValue.BinaryName, nil
}

// ClearBinaryName clears the value of the "binary_name" field.
func (m *AppPackageMutation) ClearBinaryName() {
	m.binary_name = nil
	m.clearedFields[apppackage.FieldBinaryName] = struct{}{}
}

// BinaryNameCleared returns if the "binary_name" field was cleared in this mutation.
func (m *AppPackageMutation) BinaryNameCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldBinaryName]
	return ok
}

// ResetBinaryName resets all changes to the "binary_name" field.
func (m *AppPackageMutation) ResetBinaryName() {
	m.binary_name = nil
	delete(m.clearedFields, apppackage.FieldBinaryName)
}

// SetBinarySizeBytes sets the "binary_size_bytes" field.
func (m *AppPackageMutation) SetBinarySizeBytes(i int64) {
	m.binary_size_bytes = &i
	m.addbinary_size_bytes = nil
}

// BinarySizeBytes returns the value of the "binary_size_bytes" field in the mutation.
func (m *AppPackageMutation) BinarySizeBytes() (r int64, exists bool) {
	v := m.binary_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldBinarySizeBytes returns the old "binary_size_bytes" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldBinarySizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinarySizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinarySizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinarySizeBytes: %w", err)
	}
	return oldValue.BinarySizeBytes, nil
}

// AddBinarySizeBytes adds i to the "binary_size_bytes" field.
func (m *AppPackageMutation) AddBinarySizeBytes(i int64) {
	if m.addbinary_size_bytes != nil {
		*m.addbinary_size_bytes += i
	} else {
		m.addbinary_size_bytes = &i
	}
}

// AddedBinarySizeBytes returns the value that was added to the "binary_size_bytes" field in this mutation.
func (m *AppPackageMutation) AddedBinarySizeBytes() (r int64, exists bool) {
	v := m.addbinary_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearBinarySizeBytes clears the value of the "binary_size_bytes" field.
func (m *AppPackageMutation) ClearBinarySizeBytes() {
	m.binary_size_bytes = nil
	m.addbinary_size_bytes = nil
	m.clearedFields[apppackage.FieldBinarySizeBytes] = struct{}{}
}

// BinarySizeBytesCleared returns if the "binary_size_bytes" field was cleared in this mutation.
func (m *AppPackageMutation) BinarySizeBytesCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldBinarySizeBytes]
	return ok
}

// ResetBinarySizeBytes resets all changes to the "binary_size_bytes" field.
func (m *AppPackageMutation) ResetBinarySizeBytes() {
	m.binary_size_bytes = nil
	m.addbinary_size_bytes = nil
	delete(m.clearedFields, apppackage.FieldBinarySizeBytes)
}

// SetBinaryPublicURL sets the "binary_public_url" field.
func (m *AppPackageMutation) SetBinaryPublicURL(s string) {
	m.binary_public_url = &s
}

// BinaryPublicURL returns the value of the "binary_public_url" field in the mutation.
func (m *AppPackageMutation) BinaryPublicURL() (r string, exists bool) {
	v := m.binary_public_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryPublicURL returns the old "binary_public_url" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldBinaryPublicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryPublicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryPublicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryPublicURL: %w", err)
	}
	return oldValue.BinaryPublicURL, nil
}

// ClearBinaryPublicURL clears the value of the "binary_public_url" field.
func (m *AppPackageMutation) ClearBinaryPublicURL() {
	m.binary_public_url = nil
	m.clearedFields[apppackage.FieldBinaryPublicURL] = struct{}{}
}

// BinaryPublicURLCleared returns if the "binary_public_url" field was cleared in this mutation.
func (m *AppPackageMutation) BinaryPublicURLCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldBinaryPublicURL]
	return ok
}

// ResetBinaryPublicURL resets all changes to the "binary_public_url" field.
func (m *AppPackageMutation) ResetBinaryPublicURL() {
	m.binary_public_url = nil
	delete(m.clearedFields, apppackage.FieldBinaryPublicURL)
}

// SetBinarySha256 sets the "binary_sha256" field.
func (m *AppPackageMutation) SetBinarySha256(b []byte) {
	m.binary_sha256 = &b
}

// BinarySha256 returns the value of the "binary_sha256" field in the mutation.
func (m *AppPackageMutation) BinarySha256() (r []byte, exists bool) {
	v := m.binary_sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldBinarySha256 returns the old "binary_sha256" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldBinarySha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinarySha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinarySha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinarySha256: %w", err)
	}
	return oldValue.BinarySha256, nil
}

// ClearBinarySha256 clears the value of the "binary_sha256" field.
func (m *AppPackageMutation) ClearBinarySha256() {
	m.binary_sha256 = nil
	m.clearedFields[apppackage.FieldBinarySha256] = struct{}{}
}

// BinarySha256Cleared returns if the "binary_sha256" field was cleared in this mutation.
func (m *AppPackageMutation) BinarySha256Cleared() bool {
	_, ok := m.clearedFields[apppackage.FieldBinarySha256]
	return ok
}

// ResetBinarySha256 resets all changes to the "binary_sha256" field.
func (m *AppPackageMutation) ResetBinarySha256() {
	m.binary_sha256 = nil
	delete(m.clearedFields, apppackage.FieldBinarySha256)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPackageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPackageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPackageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPackageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPackageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPackageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AppPackageMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AppPackageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AppPackageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AppPackageMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppPackageMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppPackageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *AppPackageMutation) SetAppID(id model.InternalID) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppPackageMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppPackageMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *AppPackageMutation) AppID() (id model.InternalID, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppPackageMutation) AppIDs() (ids []model.InternalID) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppPackageMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppPackageMutation builder.
func (m *AppPackageMutation) Where(ps ...predicate.AppPackage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPackageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPackageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPackage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPackageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPackageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPackage).
func (m *AppPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPackageMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.source != nil {
		fields = append(fields, apppackage.FieldSource)
	}
	if m.source_id != nil {
		fields = append(fields, apppackage.FieldSourceID)
	}
	if m.name != nil {
		fields = append(fields, apppackage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, apppackage.FieldDescription)
	}
	if m.public != nil {
		fields = append(fields, apppackage.FieldPublic)
	}
	if m.binary_name != nil {
		fields = append(fields, apppackage.FieldBinaryName)
	}
	if m.binary_size_bytes != nil {
		fields = append(fields, apppackage.FieldBinarySizeBytes)
	}
	if m.binary_public_url != nil {
		fields = append(fields, apppackage.FieldBinaryPublicURL)
	}
	if m.binary_sha256 != nil {
		fields = append(fields, apppackage.FieldBinarySha256)
	}
	if m.updated_at != nil {
		fields = append(fields, apppackage.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apppackage.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppackage.FieldSource:
		return m.Source()
	case apppackage.FieldSourceID:
		return m.SourceID()
	case apppackage.FieldName:
		return m.Name()
	case apppackage.FieldDescription:
		return m.Description()
	case apppackage.FieldPublic:
		return m.Public()
	case apppackage.FieldBinaryName:
		return m.BinaryName()
	case apppackage.FieldBinarySizeBytes:
		return m.BinarySizeBytes()
	case apppackage.FieldBinaryPublicURL:
		return m.BinaryPublicURL()
	case apppackage.FieldBinarySha256:
		return m.BinarySha256()
	case apppackage.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppackage.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppackage.FieldSource:
		return m.OldSource(ctx)
	case apppackage.FieldSourceID:
		return m.OldSourceID(ctx)
	case apppackage.FieldName:
		return m.OldName(ctx)
	case apppackage.FieldDescription:
		return m.OldDescription(ctx)
	case apppackage.FieldPublic:
		return m.OldPublic(ctx)
	case apppackage.FieldBinaryName:
		return m.OldBinaryName(ctx)
	case apppackage.FieldBinarySizeBytes:
		return m.OldBinarySizeBytes(ctx)
	case apppackage.FieldBinaryPublicURL:
		return m.OldBinaryPublicURL(ctx)
	case apppackage.FieldBinarySha256:
		return m.OldBinarySha256(ctx)
	case apppackage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppackage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppackage.FieldSource:
		v, ok := value.(apppackage.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case apppackage.FieldSourceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case apppackage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apppackage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case apppackage.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case apppackage.FieldBinaryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryName(v)
		return nil
	case apppackage.FieldBinarySizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinarySizeBytes(v)
		return nil
	case apppackage.FieldBinaryPublicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryPublicURL(v)
		return nil
	case apppackage.FieldBinarySha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinarySha256(v)
		return nil
	case apppackage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppackage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPackageMutation) AddedFields() []string {
	var fields []string
	if m.addsource_id != nil {
		fields = append(fields, apppackage.FieldSourceID)
	}
	if m.addbinary_size_bytes != nil {
		fields = append(fields, apppackage.FieldBinarySizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppackage.FieldSourceID:
		return m.AddedSourceID()
	case apppackage.FieldBinarySizeBytes:
		return m.AddedBinarySizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppackage.FieldSourceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceID(v)
		return nil
	case apppackage.FieldBinarySizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBinarySizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppackage.FieldBinaryName) {
		fields = append(fields, apppackage.FieldBinaryName)
	}
	if m.FieldCleared(apppackage.FieldBinarySizeBytes) {
		fields = append(fields, apppackage.FieldBinarySizeBytes)
	}
	if m.FieldCleared(apppackage.FieldBinaryPublicURL) {
		fields = append(fields, apppackage.FieldBinaryPublicURL)
	}
	if m.FieldCleared(apppackage.FieldBinarySha256) {
		fields = append(fields, apppackage.FieldBinarySha256)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPackageMutation) ClearField(name string) error {
	switch name {
	case apppackage.FieldBinaryName:
		m.ClearBinaryName()
		return nil
	case apppackage.FieldBinarySizeBytes:
		m.ClearBinarySizeBytes()
		return nil
	case apppackage.FieldBinaryPublicURL:
		m.ClearBinaryPublicURL()
		return nil
	case apppackage.FieldBinarySha256:
		m.ClearBinarySha256()
		return nil
	}
	return fmt.Errorf("unknown AppPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPackageMutation) ResetField(name string) error {
	switch name {
	case apppackage.FieldSource:
		m.ResetSource()
		return nil
	case apppackage.FieldSourceID:
		m.ResetSourceID()
		return nil
	case apppackage.FieldName:
		m.ResetName()
		return nil
	case apppackage.FieldDescription:
		m.ResetDescription()
		return nil
	case apppackage.FieldPublic:
		m.ResetPublic()
		return nil
	case apppackage.FieldBinaryName:
		m.ResetBinaryName()
		return nil
	case apppackage.FieldBinarySizeBytes:
		m.ResetBinarySizeBytes()
		return nil
	case apppackage.FieldBinaryPublicURL:
		m.ResetBinaryPublicURL()
		return nil
	case apppackage.FieldBinarySha256:
		m.ResetBinarySha256()
		return nil
	case apppackage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppackage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, apppackage.EdgeOwner)
	}
	if m.app != nil {
		edges = append(edges, apppackage.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPackageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apppackage.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case apppackage.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPackageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, apppackage.EdgeOwner)
	}
	if m.clearedapp {
		edges = append(edges, apppackage.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPackageMutation) EdgeCleared(name string) bool {
	switch name {
	case apppackage.EdgeOwner:
		return m.clearedowner
	case apppackage.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPackageMutation) ClearEdge(name string) error {
	switch name {
	case apppackage.EdgeOwner:
		m.ClearOwner()
		return nil
	case apppackage.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPackageMutation) ResetEdge(name string) error {
	switch name {
	case apppackage.EdgeOwner:
		m.ResetOwner()
		return nil
	case apppackage.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppPackage edge %s", name)
}

// AppPackageRunTimeMutation represents an operation that mutates the AppPackageRunTime nodes in the graph.
type AppPackageRunTimeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	user_id           *model.InternalID
	adduser_id        *model.InternalID
	app_package_id    *model.InternalID
	addapp_package_id *model.InternalID
	start_time        *time.Time
	run_duration      *time.Duration
	addrun_duration   *time.Duration
	updated_at        *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*AppPackageRunTime, error)
	predicates        []predicate.AppPackageRunTime
}

var _ ent.Mutation = (*AppPackageRunTimeMutation)(nil)

// apppackageruntimeOption allows management of the mutation configuration using functional options.
type apppackageruntimeOption func(*AppPackageRunTimeMutation)

// newAppPackageRunTimeMutation creates new mutation for the AppPackageRunTime entity.
func newAppPackageRunTimeMutation(c config, op Op, opts ...apppackageruntimeOption) *AppPackageRunTimeMutation {
	m := &AppPackageRunTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPackageRunTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPackageRunTimeID sets the ID field of the mutation.
func withAppPackageRunTimeID(id int) apppackageruntimeOption {
	return func(m *AppPackageRunTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPackageRunTime
		)
		m.oldValue = func(ctx context.Context) (*AppPackageRunTime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPackageRunTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPackageRunTime sets the old AppPackageRunTime of the mutation.
func withAppPackageRunTime(node *AppPackageRunTime) apppackageruntimeOption {
	return func(m *AppPackageRunTimeMutation) {
		m.oldValue = func(context.Context) (*AppPackageRunTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPackageRunTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPackageRunTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPackageRunTimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPackageRunTimeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPackageRunTime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AppPackageRunTimeMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppPackageRunTimeMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *AppPackageRunTimeMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AppPackageRunTimeMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppPackageRunTimeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAppPackageID sets the "app_package_id" field.
func (m *AppPackageRunTimeMutation) SetAppPackageID(mi model.InternalID) {
	m.app_package_id = &mi
	m.addapp_package_id = nil
}

// AppPackageID returns the value of the "app_package_id" field in the mutation.
func (m *AppPackageRunTimeMutation) AppPackageID() (r model.InternalID, exists bool) {
	v := m.app_package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPackageID returns the old "app_package_id" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldAppPackageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPackageID: %w", err)
	}
	return oldValue.AppPackageID, nil
}

// AddAppPackageID adds mi to the "app_package_id" field.
func (m *AppPackageRunTimeMutation) AddAppPackageID(mi model.InternalID) {
	if m.addapp_package_id != nil {
		*m.addapp_package_id += mi
	} else {
		m.addapp_package_id = &mi
	}
}

// AddedAppPackageID returns the value that was added to the "app_package_id" field in this mutation.
func (m *AppPackageRunTimeMutation) AddedAppPackageID() (r model.InternalID, exists bool) {
	v := m.addapp_package_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppPackageID resets all changes to the "app_package_id" field.
func (m *AppPackageRunTimeMutation) ResetAppPackageID() {
	m.app_package_id = nil
	m.addapp_package_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *AppPackageRunTimeMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *AppPackageRunTimeMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *AppPackageRunTimeMutation) ResetStartTime() {
	m.start_time = nil
}

// SetRunDuration sets the "run_duration" field.
func (m *AppPackageRunTimeMutation) SetRunDuration(t time.Duration) {
	m.run_duration = &t
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *AppPackageRunTimeMutation) RunDuration() (r time.Duration, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldRunDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds t to the "run_duration" field.
func (m *AppPackageRunTimeMutation) AddRunDuration(t time.Duration) {
	if m.addrun_duration != nil {
		*m.addrun_duration += t
	} else {
		m.addrun_duration = &t
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *AppPackageRunTimeMutation) AddedRunDuration() (r time.Duration, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *AppPackageRunTimeMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPackageRunTimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPackageRunTimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPackageRunTimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPackageRunTimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPackageRunTimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPackageRunTime entity.
// If the AppPackageRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageRunTimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPackageRunTimeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AppPackageRunTimeMutation builder.
func (m *AppPackageRunTimeMutation) Where(ps ...predicate.AppPackageRunTime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPackageRunTimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPackageRunTimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPackageRunTime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPackageRunTimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPackageRunTimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPackageRunTime).
func (m *AppPackageRunTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPackageRunTimeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, apppackageruntime.FieldUserID)
	}
	if m.app_package_id != nil {
		fields = append(fields, apppackageruntime.FieldAppPackageID)
	}
	if m.start_time != nil {
		fields = append(fields, apppackageruntime.FieldStartTime)
	}
	if m.run_duration != nil {
		fields = append(fields, apppackageruntime.FieldRunDuration)
	}
	if m.updated_at != nil {
		fields = append(fields, apppackageruntime.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apppackageruntime.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPackageRunTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppackageruntime.FieldUserID:
		return m.UserID()
	case apppackageruntime.FieldAppPackageID:
		return m.AppPackageID()
	case apppackageruntime.FieldStartTime:
		return m.StartTime()
	case apppackageruntime.FieldRunDuration:
		return m.RunDuration()
	case apppackageruntime.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppackageruntime.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPackageRunTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppackageruntime.FieldUserID:
		return m.OldUserID(ctx)
	case apppackageruntime.FieldAppPackageID:
		return m.OldAppPackageID(ctx)
	case apppackageruntime.FieldStartTime:
		return m.OldStartTime(ctx)
	case apppackageruntime.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case apppackageruntime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppackageruntime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppPackageRunTime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageRunTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppackageruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apppackageruntime.FieldAppPackageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPackageID(v)
		return nil
	case apppackageruntime.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case apppackageruntime.FieldRunDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case apppackageruntime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppackageruntime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackageRunTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPackageRunTimeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, apppackageruntime.FieldUserID)
	}
	if m.addapp_package_id != nil {
		fields = append(fields, apppackageruntime.FieldAppPackageID)
	}
	if m.addrun_duration != nil {
		fields = append(fields, apppackageruntime.FieldRunDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPackageRunTimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppackageruntime.FieldUserID:
		return m.AddedUserID()
	case apppackageruntime.FieldAppPackageID:
		return m.AddedAppPackageID()
	case apppackageruntime.FieldRunDuration:
		return m.AddedRunDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageRunTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppackageruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case apppackageruntime.FieldAppPackageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppPackageID(v)
		return nil
	case apppackageruntime.FieldRunDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackageRunTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPackageRunTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPackageRunTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPackageRunTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppPackageRunTime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPackageRunTimeMutation) ResetField(name string) error {
	switch name {
	case apppackageruntime.FieldUserID:
		m.ResetUserID()
		return nil
	case apppackageruntime.FieldAppPackageID:
		m.ResetAppPackageID()
		return nil
	case apppackageruntime.FieldStartTime:
		m.ResetStartTime()
		return nil
	case apppackageruntime.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case apppackageruntime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppackageruntime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppPackageRunTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPackageRunTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPackageRunTimeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPackageRunTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPackageRunTimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPackageRunTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPackageRunTimeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPackageRunTimeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppPackageRunTime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPackageRunTimeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppPackageRunTime edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                         Op
	typ                        string
	id                         *model.InternalID
	device_model               *string
	system_version             *string
	client_name                *string
	client_source_code_address *string
	client_version             *string
	updated_at                 *time.Time
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	user_session               map[model.InternalID]struct{}
	removeduser_session        map[model.InternalID]struct{}
	cleareduser_session        bool
	done                       bool
	oldValue                   func(context.Context) (*DeviceInfo, error)
	predicates                 []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id model.InternalID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceModel sets the "device_model" field.
func (m *DeviceInfoMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *DeviceInfoMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *DeviceInfoMutation) ResetDeviceModel() {
	m.device_model = nil
}

// SetSystemVersion sets the "system_version" field.
func (m *DeviceInfoMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *DeviceInfoMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *DeviceInfoMutation) ResetSystemVersion() {
	m.system_version = nil
}

// SetClientName sets the "client_name" field.
func (m *DeviceInfoMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *DeviceInfoMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *DeviceInfoMutation) ResetClientName() {
	m.client_name = nil
}

// SetClientSourceCodeAddress sets the "client_source_code_address" field.
func (m *DeviceInfoMutation) SetClientSourceCodeAddress(s string) {
	m.client_source_code_address = &s
}

// ClientSourceCodeAddress returns the value of the "client_source_code_address" field in the mutation.
func (m *DeviceInfoMutation) ClientSourceCodeAddress() (r string, exists bool) {
	v := m.client_source_code_address
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSourceCodeAddress returns the old "client_source_code_address" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientSourceCodeAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSourceCodeAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSourceCodeAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSourceCodeAddress: %w", err)
	}
	return oldValue.ClientSourceCodeAddress, nil
}

// ResetClientSourceCodeAddress resets all changes to the "client_source_code_address" field.
func (m *DeviceInfoMutation) ResetClientSourceCodeAddress() {
	m.client_source_code_address = nil
}

// SetClientVersion sets the "client_version" field.
func (m *DeviceInfoMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *DeviceInfoMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *DeviceInfoMutation) ResetClientVersion() {
	m.client_version = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserSessionIDs adds the "user_session" edge to the UserSession entity by ids.
func (m *DeviceInfoMutation) AddUserSessionIDs(ids ...model.InternalID) {
	if m.user_session == nil {
		m.user_session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.user_session[ids[i]] = struct{}{}
	}
}

// ClearUserSession clears the "user_session" edge to the UserSession entity.
func (m *DeviceInfoMutation) ClearUserSession() {
	m.cleareduser_session = true
}

// UserSessionCleared reports if the "user_session" edge to the UserSession entity was cleared.
func (m *DeviceInfoMutation) UserSessionCleared() bool {
	return m.cleareduser_session
}

// RemoveUserSessionIDs removes the "user_session" edge to the UserSession entity by IDs.
func (m *DeviceInfoMutation) RemoveUserSessionIDs(ids ...model.InternalID) {
	if m.removeduser_session == nil {
		m.removeduser_session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.user_session, ids[i])
		m.removeduser_session[ids[i]] = struct{}{}
	}
}

// RemovedUserSession returns the removed IDs of the "user_session" edge to the UserSession entity.
func (m *DeviceInfoMutation) RemovedUserSessionIDs() (ids []model.InternalID) {
	for id := range m.removeduser_session {
		ids = append(ids, id)
	}
	return
}

// UserSessionIDs returns the "user_session" edge IDs in the mutation.
func (m *DeviceInfoMutation) UserSessionIDs() (ids []model.InternalID) {
	for id := range m.user_session {
		ids = append(ids, id)
	}
	return
}

// ResetUserSession resets all changes to the "user_session" edge.
func (m *DeviceInfoMutation) ResetUserSession() {
	m.user_session = nil
	m.cleareduser_session = false
	m.removeduser_session = nil
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.device_model != nil {
		fields = append(fields, deviceinfo.FieldDeviceModel)
	}
	if m.system_version != nil {
		fields = append(fields, deviceinfo.FieldSystemVersion)
	}
	if m.client_name != nil {
		fields = append(fields, deviceinfo.FieldClientName)
	}
	if m.client_source_code_address != nil {
		fields = append(fields, deviceinfo.FieldClientSourceCodeAddress)
	}
	if m.client_version != nil {
		fields = append(fields, deviceinfo.FieldClientVersion)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldDeviceModel:
		return m.DeviceModel()
	case deviceinfo.FieldSystemVersion:
		return m.SystemVersion()
	case deviceinfo.FieldClientName:
		return m.ClientName()
	case deviceinfo.FieldClientSourceCodeAddress:
		return m.ClientSourceCodeAddress()
	case deviceinfo.FieldClientVersion:
		return m.ClientVersion()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case deviceinfo.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case deviceinfo.FieldClientName:
		return m.OldClientName(ctx)
	case deviceinfo.FieldClientSourceCodeAddress:
		return m.OldClientSourceCodeAddress(ctx)
	case deviceinfo.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case deviceinfo.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case deviceinfo.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case deviceinfo.FieldClientSourceCodeAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSourceCodeAddress(v)
		return nil
	case deviceinfo.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case deviceinfo.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case deviceinfo.FieldClientName:
		m.ResetClientName()
		return nil
	case deviceinfo.FieldClientSourceCodeAddress:
		m.ResetClientSourceCodeAddress()
		return nil
	case deviceinfo.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_session != nil {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeUserSession:
		ids := make([]ent.Value, 0, len(m.user_session))
		for id := range m.user_session {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_session != nil {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeUserSession:
		ids := make([]ent.Value, 0, len(m.removeduser_session))
		for id := range m.removeduser_session {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_session {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinfo.EdgeUserSession:
		return m.cleareduser_session
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	switch name {
	case deviceinfo.EdgeUserSession:
		m.ResetUserSession()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// FeedMutation represents an operation that mutates the Feed nodes in the graph.
type FeedMutation struct {
	config
	op             Op
	typ            string
	id             *model.InternalID
	title          *string
	link           *string
	description    *string
	language       *string
	authors        *[]*modelfeed.Person
	appendauthors  []*modelfeed.Person
	image          **modelfeed.Image
	updated_at     *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	item           map[model.InternalID]struct{}
	removeditem    map[model.InternalID]struct{}
	cleareditem    bool
	_config        *model.InternalID
	cleared_config bool
	done           bool
	oldValue       func(context.Context) (*Feed, error)
	predicates     []predicate.Feed
}

var _ ent.Mutation = (*FeedMutation)(nil)

// feedOption allows management of the mutation configuration using functional options.
type feedOption func(*FeedMutation)

// newFeedMutation creates new mutation for the Feed entity.
func newFeedMutation(c config, op Op, opts ...feedOption) *FeedMutation {
	m := &FeedMutation{
		config:        c,
		op:            op,
		typ:           TypeFeed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedID sets the ID field of the mutation.
func withFeedID(id model.InternalID) feedOption {
	return func(m *FeedMutation) {
		var (
			err   error
			once  sync.Once
			value *Feed
		)
		m.oldValue = func(ctx context.Context) (*Feed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeed sets the old Feed of the mutation.
func withFeed(node *Feed) feedOption {
	return func(m *FeedMutation) {
		m.oldValue = func(context.Context) (*Feed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feed entities.
func (m *FeedMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *FeedMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feed.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feed.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feed.FieldTitle)
}

// SetLink sets the "link" field.
func (m *FeedMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feed.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feed.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feed.FieldLink)
}

// SetDescription sets the "description" field.
func (m *FeedMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feed.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feed.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feed.FieldDescription)
}

// SetLanguage sets the "language" field.
func (m *FeedMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *FeedMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *FeedMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[feed.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *FeedMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[feed.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *FeedMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, feed.FieldLanguage)
}

// SetAuthors sets the "authors" field.
func (m *FeedMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feed.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feed.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feed.FieldAuthors)
}

// SetImage sets the "image" field.
func (m *FeedMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feed.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feed.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feed.FieldImage)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddItemIDs adds the "item" edge to the FeedItem entity by ids.
func (m *FeedMutation) AddItemIDs(ids ...model.InternalID) {
	if m.item == nil {
		m.item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the FeedItem entity.
func (m *FeedMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the FeedItem entity was cleared.
func (m *FeedMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the FeedItem entity by IDs.
func (m *FeedMutation) RemoveItemIDs(ids ...model.InternalID) {
	if m.removeditem == nil {
		m.removeditem = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the FeedItem entity.
func (m *FeedMutation) RemovedItemIDs() (ids []model.InternalID) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *FeedMutation) ItemIDs() (ids []model.InternalID) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *FeedMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// SetConfigID sets the "config" edge to the FeedConfig entity by id.
func (m *FeedMutation) SetConfigID(id model.InternalID) {
	m._config = &id
}

// ClearConfig clears the "config" edge to the FeedConfig entity.
func (m *FeedMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the FeedConfig entity was cleared.
func (m *FeedMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the "config" edge ID in the mutation.
func (m *FeedMutation) ConfigID() (id model.InternalID, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *FeedMutation) ConfigIDs() (ids []model.InternalID) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *FeedMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Where appends a list predicates to the FeedMutation builder.
func (m *FeedMutation) Where(ps ...predicate.Feed) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feed, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feed).
func (m *FeedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, feed.FieldTitle)
	}
	if m.link != nil {
		fields = append(fields, feed.FieldLink)
	}
	if m.description != nil {
		fields = append(fields, feed.FieldDescription)
	}
	if m.language != nil {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.authors != nil {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.image != nil {
		fields = append(fields, feed.FieldImage)
	}
	if m.updated_at != nil {
		fields = append(fields, feed.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feed.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feed.FieldTitle:
		return m.Title()
	case feed.FieldLink:
		return m.Link()
	case feed.FieldDescription:
		return m.Description()
	case feed.FieldLanguage:
		return m.Language()
	case feed.FieldAuthors:
		return m.Authors()
	case feed.FieldImage:
		return m.Image()
	case feed.FieldUpdatedAt:
		return m.UpdatedAt()
	case feed.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feed.FieldTitle:
		return m.OldTitle(ctx)
	case feed.FieldLink:
		return m.OldLink(ctx)
	case feed.FieldDescription:
		return m.OldDescription(ctx)
	case feed.FieldLanguage:
		return m.OldLanguage(ctx)
	case feed.FieldAuthors:
		return m.OldAuthors(ctx)
	case feed.FieldImage:
		return m.OldImage(ctx)
	case feed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feed.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feed.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feed.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feed.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case feed.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feed.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feed.FieldTitle) {
		fields = append(fields, feed.FieldTitle)
	}
	if m.FieldCleared(feed.FieldLink) {
		fields = append(fields, feed.FieldLink)
	}
	if m.FieldCleared(feed.FieldDescription) {
		fields = append(fields, feed.FieldDescription)
	}
	if m.FieldCleared(feed.FieldLanguage) {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.FieldCleared(feed.FieldAuthors) {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.FieldCleared(feed.FieldImage) {
		fields = append(fields, feed.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedMutation) ClearField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ClearTitle()
		return nil
	case feed.FieldLink:
		m.ClearLink()
		return nil
	case feed.FieldDescription:
		m.ClearDescription()
		return nil
	case feed.FieldLanguage:
		m.ClearLanguage()
		return nil
	case feed.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feed.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Feed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedMutation) ResetField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ResetTitle()
		return nil
	case feed.FieldLink:
		m.ResetLink()
		return nil
	case feed.FieldDescription:
		m.ResetDescription()
		return nil
	case feed.FieldLanguage:
		m.ResetLanguage()
		return nil
	case feed.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feed.FieldImage:
		m.ResetImage()
		return nil
	case feed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, feed.EdgeItem)
	}
	if m._config != nil {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case feed.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditem != nil {
		edges = append(edges, feed.EdgeItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, feed.EdgeItem)
	}
	if m.cleared_config {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedMutation) EdgeCleared(name string) bool {
	switch name {
	case feed.EdgeItem:
		return m.cleareditem
	case feed.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedMutation) ClearEdge(name string) error {
	switch name {
	case feed.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedMutation) ResetEdge(name string) error {
	switch name {
	case feed.EdgeItem:
		m.ResetItem()
		return nil
	case feed.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed edge %s", name)
}

// FeedConfigMutation represents an operation that mutates the FeedConfig nodes in the graph.
type FeedConfigMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	feed_url                  *string
	author_account            *model.InternalID
	addauthor_account         *model.InternalID
	source                    *string
	status                    *feedconfig.Status
	category                  *string
	pull_interval             *time.Duration
	addpull_interval          *time.Duration
	hide_items                *bool
	latest_pull_at            *time.Time
	next_pull_begin_at        *time.Time
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	feed                      *model.InternalID
	clearedfeed               bool
	notify_flow               map[model.InternalID]struct{}
	removednotify_flow        map[model.InternalID]struct{}
	clearednotify_flow        bool
	notify_flow_source        map[int]struct{}
	removednotify_flow_source map[int]struct{}
	clearednotify_flow_source bool
	done                      bool
	oldValue                  func(context.Context) (*FeedConfig, error)
	predicates                []predicate.FeedConfig
}

var _ ent.Mutation = (*FeedConfigMutation)(nil)

// feedconfigOption allows management of the mutation configuration using functional options.
type feedconfigOption func(*FeedConfigMutation)

// newFeedConfigMutation creates new mutation for the FeedConfig entity.
func newFeedConfigMutation(c config, op Op, opts ...feedconfigOption) *FeedConfigMutation {
	m := &FeedConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedConfigID sets the ID field of the mutation.
func withFeedConfigID(id model.InternalID) feedconfigOption {
	return func(m *FeedConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedConfig
		)
		m.oldValue = func(ctx context.Context) (*FeedConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedConfig sets the old FeedConfig of the mutation.
func withFeedConfig(node *FeedConfig) feedconfigOption {
	return func(m *FeedConfigMutation) {
		m.oldValue = func(context.Context) (*FeedConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedConfig entities.
func (m *FeedConfigMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedConfigMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedConfigMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserFeedConfig sets the "user_feed_config" field.
func (m *FeedConfigMutation) SetUserFeedConfig(mi model.InternalID) {
	m.owner = &mi
}

// UserFeedConfig returns the value of the "user_feed_config" field in the mutation.
func (m *FeedConfigMutation) UserFeedConfig() (r model.InternalID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserFeedConfig returns the old "user_feed_config" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUserFeedConfig(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserFeedConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserFeedConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserFeedConfig: %w", err)
	}
	return oldValue.UserFeedConfig, nil
}

// ResetUserFeedConfig resets all changes to the "user_feed_config" field.
func (m *FeedConfigMutation) ResetUserFeedConfig() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *FeedConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedConfigMutation) ResetName() {
	m.name = nil
}

// SetFeedURL sets the "feed_url" field.
func (m *FeedConfigMutation) SetFeedURL(s string) {
	m.feed_url = &s
}

// FeedURL returns the value of the "feed_url" field in the mutation.
func (m *FeedConfigMutation) FeedURL() (r string, exists bool) {
	v := m.feed_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedURL returns the old "feed_url" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldFeedURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedURL: %w", err)
	}
	return oldValue.FeedURL, nil
}

// ResetFeedURL resets all changes to the "feed_url" field.
func (m *FeedConfigMutation) ResetFeedURL() {
	m.feed_url = nil
}

// SetAuthorAccount sets the "author_account" field.
func (m *FeedConfigMutation) SetAuthorAccount(mi model.InternalID) {
	m.author_account = &mi
	m.addauthor_account = nil
}

// AuthorAccount returns the value of the "author_account" field in the mutation.
func (m *FeedConfigMutation) AuthorAccount() (r model.InternalID, exists bool) {
	v := m.author_account
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAccount returns the old "author_account" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldAuthorAccount(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAccount: %w", err)
	}
	return oldValue.AuthorAccount, nil
}

// AddAuthorAccount adds mi to the "author_account" field.
func (m *FeedConfigMutation) AddAuthorAccount(mi model.InternalID) {
	if m.addauthor_account != nil {
		*m.addauthor_account += mi
	} else {
		m.addauthor_account = &mi
	}
}

// AddedAuthorAccount returns the value that was added to the "author_account" field in this mutation.
func (m *FeedConfigMutation) AddedAuthorAccount() (r model.InternalID, exists bool) {
	v := m.addauthor_account
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorAccount resets all changes to the "author_account" field.
func (m *FeedConfigMutation) ResetAuthorAccount() {
	m.author_account = nil
	m.addauthor_account = nil
}

// SetSource sets the "source" field.
func (m *FeedConfigMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FeedConfigMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FeedConfigMutation) ResetSource() {
	m.source = nil
}

// SetStatus sets the "status" field.
func (m *FeedConfigMutation) SetStatus(f feedconfig.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FeedConfigMutation) Status() (r feedconfig.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldStatus(ctx context.Context) (v feedconfig.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FeedConfigMutation) ResetStatus() {
	m.status = nil
}

// SetCategory sets the "category" field.
func (m *FeedConfigMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedConfigMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedConfigMutation) ResetCategory() {
	m.category = nil
}

// SetPullInterval sets the "pull_interval" field.
func (m *FeedConfigMutation) SetPullInterval(t time.Duration) {
	m.pull_interval = &t
	m.addpull_interval = nil
}

// PullInterval returns the value of the "pull_interval" field in the mutation.
func (m *FeedConfigMutation) PullInterval() (r time.Duration, exists bool) {
	v := m.pull_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldPullInterval returns the old "pull_interval" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldPullInterval(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullInterval: %w", err)
	}
	return oldValue.PullInterval, nil
}

// AddPullInterval adds t to the "pull_interval" field.
func (m *FeedConfigMutation) AddPullInterval(t time.Duration) {
	if m.addpull_interval != nil {
		*m.addpull_interval += t
	} else {
		m.addpull_interval = &t
	}
}

// AddedPullInterval returns the value that was added to the "pull_interval" field in this mutation.
func (m *FeedConfigMutation) AddedPullInterval() (r time.Duration, exists bool) {
	v := m.addpull_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullInterval resets all changes to the "pull_interval" field.
func (m *FeedConfigMutation) ResetPullInterval() {
	m.pull_interval = nil
	m.addpull_interval = nil
}

// SetHideItems sets the "hide_items" field.
func (m *FeedConfigMutation) SetHideItems(b bool) {
	m.hide_items = &b
}

// HideItems returns the value of the "hide_items" field in the mutation.
func (m *FeedConfigMutation) HideItems() (r bool, exists bool) {
	v := m.hide_items
	if v == nil {
		return
	}
	return *v, true
}

// OldHideItems returns the old "hide_items" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldHideItems(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideItems: %w", err)
	}
	return oldValue.HideItems, nil
}

// ResetHideItems resets all changes to the "hide_items" field.
func (m *FeedConfigMutation) ResetHideItems() {
	m.hide_items = nil
}

// SetLatestPullAt sets the "latest_pull_at" field.
func (m *FeedConfigMutation) SetLatestPullAt(t time.Time) {
	m.latest_pull_at = &t
}

// LatestPullAt returns the value of the "latest_pull_at" field in the mutation.
func (m *FeedConfigMutation) LatestPullAt() (r time.Time, exists bool) {
	v := m.latest_pull_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullAt returns the old "latest_pull_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullAt: %w", err)
	}
	return oldValue.LatestPullAt, nil
}

// ResetLatestPullAt resets all changes to the "latest_pull_at" field.
func (m *FeedConfigMutation) ResetLatestPullAt() {
	m.latest_pull_at = nil
}

// SetNextPullBeginAt sets the "next_pull_begin_at" field.
func (m *FeedConfigMutation) SetNextPullBeginAt(t time.Time) {
	m.next_pull_begin_at = &t
}

// NextPullBeginAt returns the value of the "next_pull_begin_at" field in the mutation.
func (m *FeedConfigMutation) NextPullBeginAt() (r time.Time, exists bool) {
	v := m.next_pull_begin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPullBeginAt returns the old "next_pull_begin_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldNextPullBeginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPullBeginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPullBeginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPullBeginAt: %w", err)
	}
	return oldValue.NextPullBeginAt, nil
}

// ResetNextPullBeginAt resets all changes to the "next_pull_begin_at" field.
func (m *FeedConfigMutation) ResetNextPullBeginAt() {
	m.next_pull_begin_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedConfigMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedConfigMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[feedconfig.FieldUserFeedConfig] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedConfigMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedConfigMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedConfigMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFeedID sets the "feed" edge to the Feed entity by id.
func (m *FeedConfigMutation) SetFeedID(id model.InternalID) {
	m.feed = &id
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedConfigMutation) ClearFeed() {
	m.clearedfeed = true
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedConfigMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedID returns the "feed" edge ID in the mutation.
func (m *FeedConfigMutation) FeedID() (id model.InternalID, exists bool) {
	if m.feed != nil {
		return *m.feed, true
	}
	return
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedConfigMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *FeedConfigMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *FeedConfigMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *FeedConfigMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *FeedConfigMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *FeedConfigMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *FeedConfigMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *FeedConfigMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *FeedConfigMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *FeedConfigMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *FeedConfigMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *FeedConfigMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *FeedConfigMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *FeedConfigMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *FeedConfigMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the FeedConfigMutation builder.
func (m *FeedConfigMutation) Where(ps ...predicate.FeedConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedConfig).
func (m *FeedConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedConfigMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.owner != nil {
		fields = append(fields, feedconfig.FieldUserFeedConfig)
	}
	if m.name != nil {
		fields = append(fields, feedconfig.FieldName)
	}
	if m.feed_url != nil {
		fields = append(fields, feedconfig.FieldFeedURL)
	}
	if m.author_account != nil {
		fields = append(fields, feedconfig.FieldAuthorAccount)
	}
	if m.source != nil {
		fields = append(fields, feedconfig.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, feedconfig.FieldStatus)
	}
	if m.category != nil {
		fields = append(fields, feedconfig.FieldCategory)
	}
	if m.pull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	if m.hide_items != nil {
		fields = append(fields, feedconfig.FieldHideItems)
	}
	if m.latest_pull_at != nil {
		fields = append(fields, feedconfig.FieldLatestPullAt)
	}
	if m.next_pull_begin_at != nil {
		fields = append(fields, feedconfig.FieldNextPullBeginAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feedconfig.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedconfig.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.UserFeedConfig()
	case feedconfig.FieldName:
		return m.Name()
	case feedconfig.FieldFeedURL:
		return m.FeedURL()
	case feedconfig.FieldAuthorAccount:
		return m.AuthorAccount()
	case feedconfig.FieldSource:
		return m.Source()
	case feedconfig.FieldStatus:
		return m.Status()
	case feedconfig.FieldCategory:
		return m.Category()
	case feedconfig.FieldPullInterval:
		return m.PullInterval()
	case feedconfig.FieldHideItems:
		return m.HideItems()
	case feedconfig.FieldLatestPullAt:
		return m.LatestPullAt()
	case feedconfig.FieldNextPullBeginAt:
		return m.NextPullBeginAt()
	case feedconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedconfig.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.OldUserFeedConfig(ctx)
	case feedconfig.FieldName:
		return m.OldName(ctx)
	case feedconfig.FieldFeedURL:
		return m.OldFeedURL(ctx)
	case feedconfig.FieldAuthorAccount:
		return m.OldAuthorAccount(ctx)
	case feedconfig.FieldSource:
		return m.OldSource(ctx)
	case feedconfig.FieldStatus:
		return m.OldStatus(ctx)
	case feedconfig.FieldCategory:
		return m.OldCategory(ctx)
	case feedconfig.FieldPullInterval:
		return m.OldPullInterval(ctx)
	case feedconfig.FieldHideItems:
		return m.OldHideItems(ctx)
	case feedconfig.FieldLatestPullAt:
		return m.OldLatestPullAt(ctx)
	case feedconfig.FieldNextPullBeginAt:
		return m.OldNextPullBeginAt(ctx)
	case feedconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserFeedConfig(v)
		return nil
	case feedconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedconfig.FieldFeedURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedURL(v)
		return nil
	case feedconfig.FieldAuthorAccount:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAccount(v)
		return nil
	case feedconfig.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case feedconfig.FieldStatus:
		v, ok := value.(feedconfig.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case feedconfig.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullInterval(v)
		return nil
	case feedconfig.FieldHideItems:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideItems(v)
		return nil
	case feedconfig.FieldLatestPullAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullAt(v)
		return nil
	case feedconfig.FieldNextPullBeginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPullBeginAt(v)
		return nil
	case feedconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedConfigMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_account != nil {
		fields = append(fields, feedconfig.FieldAuthorAccount)
	}
	if m.addpull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldAuthorAccount:
		return m.AddedAuthorAccount()
	case feedconfig.FieldPullInterval:
		return m.AddedPullInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldAuthorAccount:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorAccount(v)
		return nil
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullInterval(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedConfigMutation) ResetField(name string) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		m.ResetUserFeedConfig()
		return nil
	case feedconfig.FieldName:
		m.ResetName()
		return nil
	case feedconfig.FieldFeedURL:
		m.ResetFeedURL()
		return nil
	case feedconfig.FieldAuthorAccount:
		m.ResetAuthorAccount()
		return nil
	case feedconfig.FieldSource:
		m.ResetSource()
		return nil
	case feedconfig.FieldStatus:
		m.ResetStatus()
		return nil
	case feedconfig.FieldCategory:
		m.ResetCategory()
		return nil
	case feedconfig.FieldPullInterval:
		m.ResetPullInterval()
		return nil
	case feedconfig.FieldHideItems:
		m.ResetHideItems()
		return nil
	case feedconfig.FieldLatestPullAt:
		m.ResetLatestPullAt()
		return nil
	case feedconfig.FieldNextPullBeginAt:
		m.ResetNextPullBeginAt()
		return nil
	case feedconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.feed != nil {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.notify_flow != nil {
		edges = append(edges, feedconfig.EdgeNotifyFlow)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, feedconfig.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removednotify_flow != nil {
		edges = append(edges, feedconfig.EdgeNotifyFlow)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, feedconfig.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.clearedfeed {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.clearednotify_flow {
		edges = append(edges, feedconfig.EdgeNotifyFlow)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, feedconfig.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case feedconfig.EdgeOwner:
		return m.clearedowner
	case feedconfig.EdgeFeed:
		return m.clearedfeed
	case feedconfig.EdgeNotifyFlow:
		return m.clearednotify_flow
	case feedconfig.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedConfigMutation) ClearEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ClearOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedConfigMutation) ResetEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ResetOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ResetFeed()
		return nil
	case feedconfig.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case feedconfig.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig edge %s", name)
}

// FeedItemMutation represents an operation that mutates the FeedItem nodes in the graph.
type FeedItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *model.InternalID
	title               *string
	authors             *[]*modelfeed.Person
	appendauthors       []*modelfeed.Person
	description         *string
	content             *string
	guid                *string
	link                *string
	image               **modelfeed.Image
	published           *string
	published_parsed    *time.Time
	updated             *string
	updated_parsed      *time.Time
	enclosures          *[]*modelfeed.Enclosure
	appendenclosures    []*modelfeed.Enclosure
	publish_platform    *string
	read_count          *int64
	addread_count       *int64
	digest_description  *string
	digest_images       *[]*modelfeed.Image
	appenddigest_images []*modelfeed.Image
	updated_at          *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	feed                *model.InternalID
	clearedfeed         bool
	done                bool
	oldValue            func(context.Context) (*FeedItem, error)
	predicates          []predicate.FeedItem
}

var _ ent.Mutation = (*FeedItemMutation)(nil)

// feeditemOption allows management of the mutation configuration using functional options.
type feeditemOption func(*FeedItemMutation)

// newFeedItemMutation creates new mutation for the FeedItem entity.
func newFeedItemMutation(c config, op Op, opts ...feeditemOption) *FeedItemMutation {
	m := &FeedItemMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedItemID sets the ID field of the mutation.
func withFeedItemID(id model.InternalID) feeditemOption {
	return func(m *FeedItemMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedItem
		)
		m.oldValue = func(ctx context.Context) (*FeedItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedItem sets the old FeedItem of the mutation.
func withFeedItem(node *FeedItem) feeditemOption {
	return func(m *FeedItemMutation) {
		m.oldValue = func(context.Context) (*FeedItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedItem entities.
func (m *FeedItemMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedItemMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedItemMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedID sets the "feed_id" field.
func (m *FeedItemMutation) SetFeedID(mi model.InternalID) {
	m.feed = &mi
}

// FeedID returns the value of the "feed_id" field in the mutation.
func (m *FeedItemMutation) FeedID() (r model.InternalID, exists bool) {
	v := m.feed
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedID returns the old "feed_id" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldFeedID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedID: %w", err)
	}
	return oldValue.FeedID, nil
}

// ResetFeedID resets all changes to the "feed_id" field.
func (m *FeedItemMutation) ResetFeedID() {
	m.feed = nil
}

// SetTitle sets the "title" field.
func (m *FeedItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedItemMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feeditem.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedItemMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedItemMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feeditem.FieldTitle)
}

// SetAuthors sets the "authors" field.
func (m *FeedItemMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedItemMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedItemMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedItemMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedItemMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feeditem.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedItemMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedItemMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feeditem.FieldAuthors)
}

// SetDescription sets the "description" field.
func (m *FeedItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feeditem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feeditem.FieldDescription)
}

// SetContent sets the "content" field.
func (m *FeedItemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FeedItemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *FeedItemMutation) ClearContent() {
	m.content = nil
	m.clearedFields[feeditem.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *FeedItemMutation) ContentCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *FeedItemMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, feeditem.FieldContent)
}

// SetGUID sets the "guid" field.
func (m *FeedItemMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *FeedItemMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *FeedItemMutation) ResetGUID() {
	m.guid = nil
}

// SetLink sets the "link" field.
func (m *FeedItemMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedItemMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedItemMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feeditem.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedItemMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedItemMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feeditem.FieldLink)
}

// SetImage sets the "image" field.
func (m *FeedItemMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedItemMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedItemMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feeditem.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedItemMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedItemMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feeditem.FieldImage)
}

// SetPublished sets the "published" field.
func (m *FeedItemMutation) SetPublished(s string) {
	m.published = &s
}

// Published returns the value of the "published" field in the mutation.
func (m *FeedItemMutation) Published() (r string, exists bool) {
	v := m.published
	if v == nil {
		return
	}
	return *v, true
}

// OldPublished returns the old "published" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublished(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublished: %w", err)
	}
	return oldValue.Published, nil
}

// ClearPublished clears the value of the "published" field.
func (m *FeedItemMutation) ClearPublished() {
	m.published = nil
	m.clearedFields[feeditem.FieldPublished] = struct{}{}
}

// PublishedCleared returns if the "published" field was cleared in this mutation.
func (m *FeedItemMutation) PublishedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublished]
	return ok
}

// ResetPublished resets all changes to the "published" field.
func (m *FeedItemMutation) ResetPublished() {
	m.published = nil
	delete(m.clearedFields, feeditem.FieldPublished)
}

// SetPublishedParsed sets the "published_parsed" field.
func (m *FeedItemMutation) SetPublishedParsed(t time.Time) {
	m.published_parsed = &t
}

// PublishedParsed returns the value of the "published_parsed" field in the mutation.
func (m *FeedItemMutation) PublishedParsed() (r time.Time, exists bool) {
	v := m.published_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedParsed returns the old "published_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishedParsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedParsed: %w", err)
	}
	return oldValue.PublishedParsed, nil
}

// ResetPublishedParsed resets all changes to the "published_parsed" field.
func (m *FeedItemMutation) ResetPublishedParsed() {
	m.published_parsed = nil
}

// SetUpdated sets the "updated" field.
func (m *FeedItemMutation) SetUpdated(s string) {
	m.updated = &s
}

// Updated returns the value of the "updated" field in the mutation.
func (m *FeedItemMutation) Updated() (r string, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdated(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *FeedItemMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[feeditem.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *FeedItemMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, feeditem.FieldUpdated)
}

// SetUpdatedParsed sets the "updated_parsed" field.
func (m *FeedItemMutation) SetUpdatedParsed(t time.Time) {
	m.updated_parsed = &t
}

// UpdatedParsed returns the value of the "updated_parsed" field in the mutation.
func (m *FeedItemMutation) UpdatedParsed() (r time.Time, exists bool) {
	v := m.updated_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedParsed returns the old "updated_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedParsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedParsed: %w", err)
	}
	return oldValue.UpdatedParsed, nil
}

// ClearUpdatedParsed clears the value of the "updated_parsed" field.
func (m *FeedItemMutation) ClearUpdatedParsed() {
	m.updated_parsed = nil
	m.clearedFields[feeditem.FieldUpdatedParsed] = struct{}{}
}

// UpdatedParsedCleared returns if the "updated_parsed" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedParsedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdatedParsed]
	return ok
}

// ResetUpdatedParsed resets all changes to the "updated_parsed" field.
func (m *FeedItemMutation) ResetUpdatedParsed() {
	m.updated_parsed = nil
	delete(m.clearedFields, feeditem.FieldUpdatedParsed)
}

// SetEnclosures sets the "enclosures" field.
func (m *FeedItemMutation) SetEnclosures(value []*modelfeed.Enclosure) {
	m.enclosures = &value
	m.appendenclosures = nil
}

// Enclosures returns the value of the "enclosures" field in the mutation.
func (m *FeedItemMutation) Enclosures() (r []*modelfeed.Enclosure, exists bool) {
	v := m.enclosures
	if v == nil {
		return
	}
	return *v, true
}

// OldEnclosures returns the old "enclosures" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldEnclosures(ctx context.Context) (v []*modelfeed.Enclosure, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnclosures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnclosures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnclosures: %w", err)
	}
	return oldValue.Enclosures, nil
}

// AppendEnclosures adds value to the "enclosures" field.
func (m *FeedItemMutation) AppendEnclosures(value []*modelfeed.Enclosure) {
	m.appendenclosures = append(m.appendenclosures, value...)
}

// AppendedEnclosures returns the list of values that were appended to the "enclosures" field in this mutation.
func (m *FeedItemMutation) AppendedEnclosures() ([]*modelfeed.Enclosure, bool) {
	if len(m.appendenclosures) == 0 {
		return nil, false
	}
	return m.appendenclosures, true
}

// ClearEnclosures clears the value of the "enclosures" field.
func (m *FeedItemMutation) ClearEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	m.clearedFields[feeditem.FieldEnclosures] = struct{}{}
}

// EnclosuresCleared returns if the "enclosures" field was cleared in this mutation.
func (m *FeedItemMutation) EnclosuresCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldEnclosures]
	return ok
}

// ResetEnclosures resets all changes to the "enclosures" field.
func (m *FeedItemMutation) ResetEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	delete(m.clearedFields, feeditem.FieldEnclosures)
}

// SetPublishPlatform sets the "publish_platform" field.
func (m *FeedItemMutation) SetPublishPlatform(s string) {
	m.publish_platform = &s
}

// PublishPlatform returns the value of the "publish_platform" field in the mutation.
func (m *FeedItemMutation) PublishPlatform() (r string, exists bool) {
	v := m.publish_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishPlatform returns the old "publish_platform" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishPlatform: %w", err)
	}
	return oldValue.PublishPlatform, nil
}

// ClearPublishPlatform clears the value of the "publish_platform" field.
func (m *FeedItemMutation) ClearPublishPlatform() {
	m.publish_platform = nil
	m.clearedFields[feeditem.FieldPublishPlatform] = struct{}{}
}

// PublishPlatformCleared returns if the "publish_platform" field was cleared in this mutation.
func (m *FeedItemMutation) PublishPlatformCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublishPlatform]
	return ok
}

// ResetPublishPlatform resets all changes to the "publish_platform" field.
func (m *FeedItemMutation) ResetPublishPlatform() {
	m.publish_platform = nil
	delete(m.clearedFields, feeditem.FieldPublishPlatform)
}

// SetReadCount sets the "read_count" field.
func (m *FeedItemMutation) SetReadCount(i int64) {
	m.read_count = &i
	m.addread_count = nil
}

// ReadCount returns the value of the "read_count" field in the mutation.
func (m *FeedItemMutation) ReadCount() (r int64, exists bool) {
	v := m.read_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReadCount returns the old "read_count" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldReadCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadCount: %w", err)
	}
	return oldValue.ReadCount, nil
}

// AddReadCount adds i to the "read_count" field.
func (m *FeedItemMutation) AddReadCount(i int64) {
	if m.addread_count != nil {
		*m.addread_count += i
	} else {
		m.addread_count = &i
	}
}

// AddedReadCount returns the value that was added to the "read_count" field in this mutation.
func (m *FeedItemMutation) AddedReadCount() (r int64, exists bool) {
	v := m.addread_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadCount resets all changes to the "read_count" field.
func (m *FeedItemMutation) ResetReadCount() {
	m.read_count = nil
	m.addread_count = nil
}

// SetDigestDescription sets the "digest_description" field.
func (m *FeedItemMutation) SetDigestDescription(s string) {
	m.digest_description = &s
}

// DigestDescription returns the value of the "digest_description" field in the mutation.
func (m *FeedItemMutation) DigestDescription() (r string, exists bool) {
	v := m.digest_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestDescription returns the old "digest_description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestDescription: %w", err)
	}
	return oldValue.DigestDescription, nil
}

// ClearDigestDescription clears the value of the "digest_description" field.
func (m *FeedItemMutation) ClearDigestDescription() {
	m.digest_description = nil
	m.clearedFields[feeditem.FieldDigestDescription] = struct{}{}
}

// DigestDescriptionCleared returns if the "digest_description" field was cleared in this mutation.
func (m *FeedItemMutation) DigestDescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestDescription]
	return ok
}

// ResetDigestDescription resets all changes to the "digest_description" field.
func (m *FeedItemMutation) ResetDigestDescription() {
	m.digest_description = nil
	delete(m.clearedFields, feeditem.FieldDigestDescription)
}

// SetDigestImages sets the "digest_images" field.
func (m *FeedItemMutation) SetDigestImages(value []*modelfeed.Image) {
	m.digest_images = &value
	m.appenddigest_images = nil
}

// DigestImages returns the value of the "digest_images" field in the mutation.
func (m *FeedItemMutation) DigestImages() (r []*modelfeed.Image, exists bool) {
	v := m.digest_images
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestImages returns the old "digest_images" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestImages(ctx context.Context) (v []*modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestImages: %w", err)
	}
	return oldValue.DigestImages, nil
}

// AppendDigestImages adds value to the "digest_images" field.
func (m *FeedItemMutation) AppendDigestImages(value []*modelfeed.Image) {
	m.appenddigest_images = append(m.appenddigest_images, value...)
}

// AppendedDigestImages returns the list of values that were appended to the "digest_images" field in this mutation.
func (m *FeedItemMutation) AppendedDigestImages() ([]*modelfeed.Image, bool) {
	if len(m.appenddigest_images) == 0 {
		return nil, false
	}
	return m.appenddigest_images, true
}

// ClearDigestImages clears the value of the "digest_images" field.
func (m *FeedItemMutation) ClearDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	m.clearedFields[feeditem.FieldDigestImages] = struct{}{}
}

// DigestImagesCleared returns if the "digest_images" field was cleared in this mutation.
func (m *FeedItemMutation) DigestImagesCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestImages]
	return ok
}

// ResetDigestImages resets all changes to the "digest_images" field.
func (m *FeedItemMutation) ResetDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	delete(m.clearedFields, feeditem.FieldDigestImages)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedItemMutation) ClearFeed() {
	m.clearedfeed = true
	m.clearedFields[feeditem.FieldFeedID] = struct{}{}
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedItemMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedItemMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedItemMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// Where appends a list predicates to the FeedItemMutation builder.
func (m *FeedItemMutation) Where(ps ...predicate.FeedItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedItem).
func (m *FeedItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedItemMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.feed != nil {
		fields = append(fields, feeditem.FieldFeedID)
	}
	if m.title != nil {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.authors != nil {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.description != nil {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.guid != nil {
		fields = append(fields, feeditem.FieldGUID)
	}
	if m.link != nil {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.image != nil {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.published != nil {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.published_parsed != nil {
		fields = append(fields, feeditem.FieldPublishedParsed)
	}
	if m.updated != nil {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.updated_parsed != nil {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.enclosures != nil {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.publish_platform != nil {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.read_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	if m.digest_description != nil {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.digest_images != nil {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	if m.updated_at != nil {
		fields = append(fields, feeditem.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feeditem.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldFeedID:
		return m.FeedID()
	case feeditem.FieldTitle:
		return m.Title()
	case feeditem.FieldAuthors:
		return m.Authors()
	case feeditem.FieldDescription:
		return m.Description()
	case feeditem.FieldContent:
		return m.Content()
	case feeditem.FieldGUID:
		return m.GUID()
	case feeditem.FieldLink:
		return m.Link()
	case feeditem.FieldImage:
		return m.Image()
	case feeditem.FieldPublished:
		return m.Published()
	case feeditem.FieldPublishedParsed:
		return m.PublishedParsed()
	case feeditem.FieldUpdated:
		return m.Updated()
	case feeditem.FieldUpdatedParsed:
		return m.UpdatedParsed()
	case feeditem.FieldEnclosures:
		return m.Enclosures()
	case feeditem.FieldPublishPlatform:
		return m.PublishPlatform()
	case feeditem.FieldReadCount:
		return m.ReadCount()
	case feeditem.FieldDigestDescription:
		return m.DigestDescription()
	case feeditem.FieldDigestImages:
		return m.DigestImages()
	case feeditem.FieldUpdatedAt:
		return m.UpdatedAt()
	case feeditem.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feeditem.FieldFeedID:
		return m.OldFeedID(ctx)
	case feeditem.FieldTitle:
		return m.OldTitle(ctx)
	case feeditem.FieldAuthors:
		return m.OldAuthors(ctx)
	case feeditem.FieldDescription:
		return m.OldDescription(ctx)
	case feeditem.FieldContent:
		return m.OldContent(ctx)
	case feeditem.FieldGUID:
		return m.OldGUID(ctx)
	case feeditem.FieldLink:
		return m.OldLink(ctx)
	case feeditem.FieldImage:
		return m.OldImage(ctx)
	case feeditem.FieldPublished:
		return m.OldPublished(ctx)
	case feeditem.FieldPublishedParsed:
		return m.OldPublishedParsed(ctx)
	case feeditem.FieldUpdated:
		return m.OldUpdated(ctx)
	case feeditem.FieldUpdatedParsed:
		return m.OldUpdatedParsed(ctx)
	case feeditem.FieldEnclosures:
		return m.OldEnclosures(ctx)
	case feeditem.FieldPublishPlatform:
		return m.OldPublishPlatform(ctx)
	case feeditem.FieldReadCount:
		return m.OldReadCount(ctx)
	case feeditem.FieldDigestDescription:
		return m.OldDigestDescription(ctx)
	case feeditem.FieldDigestImages:
		return m.OldDigestImages(ctx)
	case feeditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feeditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldFeedID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedID(v)
		return nil
	case feeditem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feeditem.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feeditem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feeditem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case feeditem.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case feeditem.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feeditem.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feeditem.FieldPublished:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublished(v)
		return nil
	case feeditem.FieldPublishedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedParsed(v)
		return nil
	case feeditem.FieldUpdated:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case feeditem.FieldUpdatedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedParsed(v)
		return nil
	case feeditem.FieldEnclosures:
		v, ok := value.([]*modelfeed.Enclosure)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnclosures(v)
		return nil
	case feeditem.FieldPublishPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishPlatform(v)
		return nil
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadCount(v)
		return nil
	case feeditem.FieldDigestDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestDescription(v)
		return nil
	case feeditem.FieldDigestImages:
		v, ok := value.([]*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestImages(v)
		return nil
	case feeditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feeditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedItemMutation) AddedFields() []string {
	var fields []string
	if m.addread_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldReadCount:
		return m.AddedReadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadCount(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feeditem.FieldTitle) {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.FieldCleared(feeditem.FieldAuthors) {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.FieldCleared(feeditem.FieldDescription) {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.FieldCleared(feeditem.FieldContent) {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.FieldCleared(feeditem.FieldLink) {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.FieldCleared(feeditem.FieldImage) {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.FieldCleared(feeditem.FieldPublished) {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.FieldCleared(feeditem.FieldUpdated) {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.FieldCleared(feeditem.FieldUpdatedParsed) {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.FieldCleared(feeditem.FieldEnclosures) {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.FieldCleared(feeditem.FieldPublishPlatform) {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.FieldCleared(feeditem.FieldDigestDescription) {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.FieldCleared(feeditem.FieldDigestImages) {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedItemMutation) ClearField(name string) error {
	switch name {
	case feeditem.FieldTitle:
		m.ClearTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ClearDescription()
		return nil
	case feeditem.FieldContent:
		m.ClearContent()
		return nil
	case feeditem.FieldLink:
		m.ClearLink()
		return nil
	case feeditem.FieldImage:
		m.ClearImage()
		return nil
	case feeditem.FieldPublished:
		m.ClearPublished()
		return nil
	case feeditem.FieldUpdated:
		m.ClearUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ClearUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ClearEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ClearPublishPlatform()
		return nil
	case feeditem.FieldDigestDescription:
		m.ClearDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ClearDigestImages()
		return nil
	}
	return fmt.Errorf("unknown FeedItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedItemMutation) ResetField(name string) error {
	switch name {
	case feeditem.FieldFeedID:
		m.ResetFeedID()
		return nil
	case feeditem.FieldTitle:
		m.ResetTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ResetDescription()
		return nil
	case feeditem.FieldContent:
		m.ResetContent()
		return nil
	case feeditem.FieldGUID:
		m.ResetGUID()
		return nil
	case feeditem.FieldLink:
		m.ResetLink()
		return nil
	case feeditem.FieldImage:
		m.ResetImage()
		return nil
	case feeditem.FieldPublished:
		m.ResetPublished()
		return nil
	case feeditem.FieldPublishedParsed:
		m.ResetPublishedParsed()
		return nil
	case feeditem.FieldUpdated:
		m.ResetUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ResetUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ResetEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ResetPublishPlatform()
		return nil
	case feeditem.FieldReadCount:
		m.ResetReadCount()
		return nil
	case feeditem.FieldDigestDescription:
		m.ResetDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ResetDigestImages()
		return nil
	case feeditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feeditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.feed != nil {
		edges = append(edges, feeditem.EdgeFeed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feeditem.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfeed {
		edges = append(edges, feeditem.EdgeFeed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedItemMutation) EdgeCleared(name string) bool {
	switch name {
	case feeditem.EdgeFeed:
		return m.clearedfeed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedItemMutation) ClearEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedItemMutation) ResetEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ResetFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedItem edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	size          *int64
	addsize       *int64
	_type         *file.Type
	sha256        *[]byte
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	image         *model.InternalID
	clearedimage  bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id model.InternalID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetSha256 sets the "sha256" field.
func (m *FileMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *FileMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *FileMutation) ResetSha256() {
	m.sha256 = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FileMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FileMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *FileMutation) SetImageID(id model.InternalID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *FileMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *FileMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *FileMutation) ImageID() (id model.InternalID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ImageIDs() (ids []model.InternalID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *FileMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.sha256 != nil {
		fields = append(fields, file.FieldSha256)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldType:
		return m.GetType()
	case file.FieldSha256:
		return m.Sha256()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldSha256:
		return m.OldSha256(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldSha256:
		m.ResetSha256()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.image != nil {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedimage {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	description   *string
	status        *image.Status
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	file          *model.InternalID
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id model.InternalID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ImageMutation) SetStatus(i image.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *ImageMutation) Status() (r image.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldStatus(ctx context.Context) (v image.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ImageMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ImageMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ImageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ImageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ImageMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ImageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ImageMutation) SetFileID(id model.InternalID) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ImageMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ImageMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ImageMutation) FileID() (id model.InternalID, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) FileIDs() (ids []model.InternalID) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ImageMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, image.FieldName)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, image.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldName:
		return m.Name()
	case image.FieldDescription:
		return m.Description()
	case image.FieldStatus:
		return m.Status()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldName:
		return m.OldName(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldStatus:
		return m.OldStatus(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldStatus:
		v, ok := value.(image.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldName:
		m.ResetName()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldStatus:
		m.ResetStatus()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, image.EdgeOwner)
	}
	if m.file != nil {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, image.EdgeOwner)
	}
	if m.clearedfile {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeOwner:
		return m.clearedowner
	case image.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ClearOwner()
		return nil
	case image.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ResetOwner()
		return nil
	case image.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// NotifyFlowMutation represents an operation that mutates the NotifyFlow nodes in the graph.
type NotifyFlowMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	description               *string
	status                    *notifyflow.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_target             map[model.InternalID]struct{}
	removednotify_target      map[model.InternalID]struct{}
	clearednotify_target      bool
	feed_config               map[model.InternalID]struct{}
	removedfeed_config        map[model.InternalID]struct{}
	clearedfeed_config        bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	notify_flow_source        map[int]struct{}
	removednotify_flow_source map[int]struct{}
	clearednotify_flow_source bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyFlow, error)
	predicates                []predicate.NotifyFlow
}

var _ ent.Mutation = (*NotifyFlowMutation)(nil)

// notifyflowOption allows management of the mutation configuration using functional options.
type notifyflowOption func(*NotifyFlowMutation)

// newNotifyFlowMutation creates new mutation for the NotifyFlow entity.
func newNotifyFlowMutation(c config, op Op, opts ...notifyflowOption) *NotifyFlowMutation {
	m := &NotifyFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowID sets the ID field of the mutation.
func withNotifyFlowID(id model.InternalID) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlow
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlow sets the old NotifyFlow of the mutation.
func withNotifyFlow(node *NotifyFlow) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		m.oldValue = func(context.Context) (*NotifyFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyFlow entities.
func (m *NotifyFlowMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotifyFlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyFlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyFlowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyFlowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyFlowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyFlowMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *NotifyFlowMutation) SetStatus(n notifyflow.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyFlowMutation) Status() (r notifyflow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldStatus(ctx context.Context) (v notifyflow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyFlowMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyFlowMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyFlowMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyFlowMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyFlowMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyFlowMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *NotifyFlowMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *NotifyFlowMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *NotifyFlowMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *NotifyFlowMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *NotifyFlowMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *NotifyFlowMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *NotifyFlowMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the NotifyFlowMutation builder.
func (m *NotifyFlowMutation) Where(ps ...predicate.NotifyFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlow).
func (m *NotifyFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, notifyflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifyflow.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, notifyflow.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflow.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflow.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflow.FieldName:
		return m.Name()
	case notifyflow.FieldDescription:
		return m.Description()
	case notifyflow.FieldStatus:
		return m.Status()
	case notifyflow.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflow.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflow.FieldName:
		return m.OldName(ctx)
	case notifyflow.FieldDescription:
		return m.OldDescription(ctx)
	case notifyflow.FieldStatus:
		return m.OldStatus(ctx)
	case notifyflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifyflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifyflow.FieldStatus:
		v, ok := value.(notifyflow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifyflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ResetField(name string) error {
	switch name {
	case notifyflow.FieldName:
		m.ResetName()
		return nil
	case notifyflow.FieldDescription:
		m.ResetDescription()
		return nil
	case notifyflow.FieldStatus:
		m.ResetStatus()
		return nil
	case notifyflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.feed_config != nil {
		edges = append(edges, notifyflow.EdgeFeedConfig)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.removedfeed_config != nil {
		edges = append(edges, notifyflow.EdgeFeedConfig)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.clearedfeed_config {
		edges = append(edges, notifyflow.EdgeFeedConfig)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflow.EdgeOwner:
		return m.clearedowner
	case notifyflow.EdgeNotifyTarget:
		return m.clearednotify_target
	case notifyflow.EdgeFeedConfig:
		return m.clearedfeed_config
	case notifyflow.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	case notifyflow.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowMutation) ClearEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowMutation) ResetEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifyflow.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case notifyflow.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case notifyflow.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	case notifyflow.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow edge %s", name)
}

// NotifyFlowSourceMutation represents an operation that mutates the NotifyFlowSource nodes in the graph.
type NotifyFlowSourceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_source                 *model.InternalID
	clearednotify_source          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowSource, error)
	predicates                    []predicate.NotifyFlowSource
}

var _ ent.Mutation = (*NotifyFlowSourceMutation)(nil)

// notifyflowsourceOption allows management of the mutation configuration using functional options.
type notifyflowsourceOption func(*NotifyFlowSourceMutation)

// newNotifyFlowSourceMutation creates new mutation for the NotifyFlowSource entity.
func newNotifyFlowSourceMutation(c config, op Op, opts ...notifyflowsourceOption) *NotifyFlowSourceMutation {
	m := &NotifyFlowSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowSourceID sets the ID field of the mutation.
func withNotifyFlowSourceID(id int) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowSource
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowSource sets the old NotifyFlowSource of the mutation.
func withNotifyFlowSource(node *NotifyFlowSource) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifySourceID sets the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) SetNotifySourceID(mi model.InternalID) {
	m.notify_source = &mi
}

// NotifySourceID returns the value of the "notify_source_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifySourceID() (r model.InternalID, exists bool) {
	v := m.notify_source
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifySourceID returns the old "notify_source_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifySourceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifySourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifySourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifySourceID: %w", err)
	}
	return oldValue.NotifySourceID, nil
}

// ResetNotifySourceID resets all changes to the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifySourceID() {
	m.notify_source = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowSourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowSourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowSourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowSourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowSourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowSourceMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowsource.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowSourceMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowSourceMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifySource clears the "notify_source" edge to the FeedConfig entity.
func (m *NotifyFlowSourceMutation) ClearNotifySource() {
	m.clearednotify_source = true
	m.clearedFields[notifyflowsource.FieldNotifySourceID] = struct{}{}
}

// NotifySourceCleared reports if the "notify_source" edge to the FeedConfig entity was cleared.
func (m *NotifyFlowSourceMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifySourceID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifySourceIDs() (ids []model.InternalID) {
	if id := m.notify_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *NotifyFlowSourceMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
}

// Where appends a list predicates to the NotifyFlowSourceMutation builder.
func (m *NotifyFlowSourceMutation) Where(ps ...predicate.NotifyFlowSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowSource).
func (m *NotifyFlowSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowSourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowsource.FieldNotifyFlowID)
	}
	if m.notify_source != nil {
		fields = append(fields, notifyflowsource.FieldNotifySourceID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowsource.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowsource.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowsource.FieldNotifySourceID:
		return m.NotifySourceID()
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowsource.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowsource.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowsource.FieldNotifySourceID:
		return m.OldNotifySourceID(ctx)
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowsource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowsource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowsource.FieldNotifySourceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifySourceID(v)
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowsource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowsource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowSourceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetField(name string) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowsource.FieldNotifySourceID:
		m.ResetNotifySourceID()
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowsource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowsource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.notify_source != nil {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowsource.EdgeNotifySource:
		if id := m.notify_source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowSourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.clearednotify_source {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowsource.EdgeNotifySource:
		return m.clearednotify_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ClearNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource edge %s", name)
}

// NotifyFlowTargetMutation represents an operation that mutates the NotifyFlowTarget nodes in the graph.
type NotifyFlowTargetMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	channel_id                    *string
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_target                 *model.InternalID
	clearednotify_target          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowTarget, error)
	predicates                    []predicate.NotifyFlowTarget
}

var _ ent.Mutation = (*NotifyFlowTargetMutation)(nil)

// notifyflowtargetOption allows management of the mutation configuration using functional options.
type notifyflowtargetOption func(*NotifyFlowTargetMutation)

// newNotifyFlowTargetMutation creates new mutation for the NotifyFlowTarget entity.
func newNotifyFlowTargetMutation(c config, op Op, opts ...notifyflowtargetOption) *NotifyFlowTargetMutation {
	m := &NotifyFlowTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowTargetID sets the ID field of the mutation.
func withNotifyFlowTargetID(id int) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowTarget sets the old NotifyFlowTarget of the mutation.
func withNotifyFlowTarget(node *NotifyFlowTarget) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowTargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowTargetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifyTargetID sets the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyTargetID(mi model.InternalID) {
	m.notify_target = &mi
}

// NotifyTargetID returns the value of the "notify_target_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyTargetID() (r model.InternalID, exists bool) {
	v := m.notify_target
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTargetID returns the old "notify_target_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyTargetID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTargetID: %w", err)
	}
	return oldValue.NotifyTargetID, nil
}

// ResetNotifyTargetID resets all changes to the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyTargetID() {
	m.notify_target = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotifyFlowTargetMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotifyFlowTargetMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotifyFlowTargetMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowtarget.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowTargetMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
	m.clearedFields[notifyflowtarget.FieldNotifyTargetID] = struct{}{}
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyTargetID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyTargetIDs() (ids []model.InternalID) {
	if id := m.notify_target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
}

// Where appends a list predicates to the NotifyFlowTargetMutation builder.
func (m *NotifyFlowTargetMutation) Where(ps ...predicate.NotifyFlowTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowTarget).
func (m *NotifyFlowTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowTargetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyFlowID)
	}
	if m.notify_target != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyTargetID)
	}
	if m.channel_id != nil {
		fields = append(fields, notifyflowtarget.FieldChannelID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowtarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowtarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowtarget.FieldNotifyTargetID:
		return m.NotifyTargetID()
	case notifyflowtarget.FieldChannelID:
		return m.ChannelID()
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowtarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowtarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowtarget.FieldNotifyTargetID:
		return m.OldNotifyTargetID(ctx)
	case notifyflowtarget.FieldChannelID:
		return m.OldChannelID(ctx)
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowtarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowtarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTargetID(v)
		return nil
	case notifyflowtarget.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowtarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowTargetMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetField(name string) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		m.ResetNotifyTargetID()
		return nil
	case notifyflowtarget.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowtarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowtarget.EdgeNotifyTarget:
		if id := m.notify_target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowTargetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowtarget.EdgeNotifyTarget:
		return m.clearednotify_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ClearNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget edge %s", name)
}

// NotifyTargetMutation represents an operation that mutates the NotifyTarget nodes in the graph.
type NotifyTargetMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	token                     *string
	name                      *string
	description               *string
	destination               *string
	status                    *notifytarget.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_flow               map[model.InternalID]struct{}
	removednotify_flow        map[model.InternalID]struct{}
	clearednotify_flow        bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyTarget, error)
	predicates                []predicate.NotifyTarget
}

var _ ent.Mutation = (*NotifyTargetMutation)(nil)

// notifytargetOption allows management of the mutation configuration using functional options.
type notifytargetOption func(*NotifyTargetMutation)

// newNotifyTargetMutation creates new mutation for the NotifyTarget entity.
func newNotifyTargetMutation(c config, op Op, opts ...notifytargetOption) *NotifyTargetMutation {
	m := &NotifyTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyTargetID sets the ID field of the mutation.
func withNotifyTargetID(id model.InternalID) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyTarget sets the old NotifyTarget of the mutation.
func withNotifyTarget(node *NotifyTarget) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyTarget entities.
func (m *NotifyTargetMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyTargetMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyTargetMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *NotifyTargetMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *NotifyTargetMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *NotifyTargetMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *NotifyTargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyTargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyTargetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyTargetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyTargetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyTargetMutation) ResetDescription() {
	m.description = nil
}

// SetDestination sets the "destination" field.
func (m *NotifyTargetMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *NotifyTargetMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *NotifyTargetMutation) ResetDestination() {
	m.destination = nil
}

// SetStatus sets the "status" field.
func (m *NotifyTargetMutation) SetStatus(n notifytarget.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyTargetMutation) Status() (r notifytarget.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldStatus(ctx context.Context) (v notifytarget.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyTargetMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyTargetMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyTargetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyTargetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyTargetMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyTargetMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyTargetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyTargetMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// Where appends a list predicates to the NotifyTargetMutation builder.
func (m *NotifyTargetMutation) Where(ps ...predicate.NotifyTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyTarget).
func (m *NotifyTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyTargetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.token != nil {
		fields = append(fields, notifytarget.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, notifytarget.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifytarget.FieldDescription)
	}
	if m.destination != nil {
		fields = append(fields, notifytarget.FieldDestination)
	}
	if m.status != nil {
		fields = append(fields, notifytarget.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifytarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifytarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifytarget.FieldToken:
		return m.Token()
	case notifytarget.FieldName:
		return m.Name()
	case notifytarget.FieldDescription:
		return m.Description()
	case notifytarget.FieldDestination:
		return m.Destination()
	case notifytarget.FieldStatus:
		return m.Status()
	case notifytarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifytarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifytarget.FieldToken:
		return m.OldToken(ctx)
	case notifytarget.FieldName:
		return m.OldName(ctx)
	case notifytarget.FieldDescription:
		return m.OldDescription(ctx)
	case notifytarget.FieldDestination:
		return m.OldDestination(ctx)
	case notifytarget.FieldStatus:
		return m.OldStatus(ctx)
	case notifytarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifytarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifytarget.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case notifytarget.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifytarget.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifytarget.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case notifytarget.FieldStatus:
		v, ok := value.(notifytarget.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifytarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifytarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyTargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyTargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ResetField(name string) error {
	switch name {
	case notifytarget.FieldToken:
		m.ResetToken()
		return nil
	case notifytarget.FieldName:
		m.ResetName()
		return nil
	case notifytarget.FieldDescription:
		m.ResetDescription()
		return nil
	case notifytarget.FieldDestination:
		m.ResetDestination()
		return nil
	case notifytarget.FieldStatus:
		m.ResetStatus()
		return nil
	case notifytarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifytarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.notify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednotify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.clearednotify_flow {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifytarget.EdgeOwner:
		return m.clearedowner
	case notifytarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifytarget.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifytarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifytarget.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget edge %s", name)
}

// PorterInstanceMutation represents an operation that mutates the PorterInstance nodes in the graph.
type PorterInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *model.InternalID
	name            *string
	version         *string
	global_name     *string
	address         *string
	feature_summary **modeltiphereth.PorterFeatureSummary
	status          *porterinstance.Status
	updated_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PorterInstance, error)
	predicates      []predicate.PorterInstance
}

var _ ent.Mutation = (*PorterInstanceMutation)(nil)

// porterinstanceOption allows management of the mutation configuration using functional options.
type porterinstanceOption func(*PorterInstanceMutation)

// newPorterInstanceMutation creates new mutation for the PorterInstance entity.
func newPorterInstanceMutation(c config, op Op, opts ...porterinstanceOption) *PorterInstanceMutation {
	m := &PorterInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypePorterInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterInstanceID sets the ID field of the mutation.
func withPorterInstanceID(id model.InternalID) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterInstance
		)
		m.oldValue = func(ctx context.Context) (*PorterInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterInstance sets the old PorterInstance of the mutation.
func withPorterInstance(node *PorterInstance) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		m.oldValue = func(context.Context) (*PorterInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PorterInstance entities.
func (m *PorterInstanceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterInstanceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterInstanceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PorterInstanceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PorterInstanceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PorterInstanceMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PorterInstanceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PorterInstanceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PorterInstanceMutation) ResetVersion() {
	m.version = nil
}

// SetGlobalName sets the "global_name" field.
func (m *PorterInstanceMutation) SetGlobalName(s string) {
	m.global_name = &s
}

// GlobalName returns the value of the "global_name" field in the mutation.
func (m *PorterInstanceMutation) GlobalName() (r string, exists bool) {
	v := m.global_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalName returns the old "global_name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldGlobalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalName: %w", err)
	}
	return oldValue.GlobalName, nil
}

// ResetGlobalName resets all changes to the "global_name" field.
func (m *PorterInstanceMutation) ResetGlobalName() {
	m.global_name = nil
}

// SetAddress sets the "address" field.
func (m *PorterInstanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PorterInstanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PorterInstanceMutation) ResetAddress() {
	m.address = nil
}

// SetFeatureSummary sets the "feature_summary" field.
func (m *PorterInstanceMutation) SetFeatureSummary(mfs *modeltiphereth.PorterFeatureSummary) {
	m.feature_summary = &mfs
}

// FeatureSummary returns the value of the "feature_summary" field in the mutation.
func (m *PorterInstanceMutation) FeatureSummary() (r *modeltiphereth.PorterFeatureSummary, exists bool) {
	v := m.feature_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureSummary returns the old "feature_summary" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldFeatureSummary(ctx context.Context) (v *modeltiphereth.PorterFeatureSummary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureSummary: %w", err)
	}
	return oldValue.FeatureSummary, nil
}

// ResetFeatureSummary resets all changes to the "feature_summary" field.
func (m *PorterInstanceMutation) ResetFeatureSummary() {
	m.feature_summary = nil
}

// SetStatus sets the "status" field.
func (m *PorterInstanceMutation) SetStatus(po porterinstance.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PorterInstanceMutation) Status() (r porterinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldStatus(ctx context.Context) (v porterinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PorterInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the PorterInstanceMutation builder.
func (m *PorterInstanceMutation) Where(ps ...predicate.PorterInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterInstance).
func (m *PorterInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterInstanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, porterinstance.FieldName)
	}
	if m.version != nil {
		fields = append(fields, porterinstance.FieldVersion)
	}
	if m.global_name != nil {
		fields = append(fields, porterinstance.FieldGlobalName)
	}
	if m.address != nil {
		fields = append(fields, porterinstance.FieldAddress)
	}
	if m.feature_summary != nil {
		fields = append(fields, porterinstance.FieldFeatureSummary)
	}
	if m.status != nil {
		fields = append(fields, porterinstance.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, porterinstance.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, porterinstance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case porterinstance.FieldName:
		return m.Name()
	case porterinstance.FieldVersion:
		return m.Version()
	case porterinstance.FieldGlobalName:
		return m.GlobalName()
	case porterinstance.FieldAddress:
		return m.Address()
	case porterinstance.FieldFeatureSummary:
		return m.FeatureSummary()
	case porterinstance.FieldStatus:
		return m.Status()
	case porterinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case porterinstance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case porterinstance.FieldName:
		return m.OldName(ctx)
	case porterinstance.FieldVersion:
		return m.OldVersion(ctx)
	case porterinstance.FieldGlobalName:
		return m.OldGlobalName(ctx)
	case porterinstance.FieldAddress:
		return m.OldAddress(ctx)
	case porterinstance.FieldFeatureSummary:
		return m.OldFeatureSummary(ctx)
	case porterinstance.FieldStatus:
		return m.OldStatus(ctx)
	case porterinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case porterinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case porterinstance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case porterinstance.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case porterinstance.FieldGlobalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalName(v)
		return nil
	case porterinstance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case porterinstance.FieldFeatureSummary:
		v, ok := value.(*modeltiphereth.PorterFeatureSummary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureSummary(v)
		return nil
	case porterinstance.FieldStatus:
		v, ok := value.(porterinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case porterinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case porterinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PorterInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ResetField(name string) error {
	switch name {
	case porterinstance.FieldName:
		m.ResetName()
		return nil
	case porterinstance.FieldVersion:
		m.ResetVersion()
		return nil
	case porterinstance.FieldGlobalName:
		m.ResetGlobalName()
		return nil
	case porterinstance.FieldAddress:
		m.ResetAddress()
		return nil
	case porterinstance.FieldFeatureSummary:
		m.ResetFeatureSummary()
		return nil
	case porterinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case porterinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case porterinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance edge %s", name)
}

// PorterPrivilegeMutation represents an operation that mutates the PorterPrivilege nodes in the graph.
type PorterPrivilegeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *model.InternalID
	adduser_id    *model.InternalID
	porter_id     *model.InternalID
	addporter_id  *model.InternalID
	privilege     **modeltiphereth.PorterInstancePrivilege
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PorterPrivilege, error)
	predicates    []predicate.PorterPrivilege
}

var _ ent.Mutation = (*PorterPrivilegeMutation)(nil)

// porterprivilegeOption allows management of the mutation configuration using functional options.
type porterprivilegeOption func(*PorterPrivilegeMutation)

// newPorterPrivilegeMutation creates new mutation for the PorterPrivilege entity.
func newPorterPrivilegeMutation(c config, op Op, opts ...porterprivilegeOption) *PorterPrivilegeMutation {
	m := &PorterPrivilegeMutation{
		config:        c,
		op:            op,
		typ:           TypePorterPrivilege,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterPrivilegeID sets the ID field of the mutation.
func withPorterPrivilegeID(id int) porterprivilegeOption {
	return func(m *PorterPrivilegeMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterPrivilege
		)
		m.oldValue = func(ctx context.Context) (*PorterPrivilege, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterPrivilege.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterPrivilege sets the old PorterPrivilege of the mutation.
func withPorterPrivilege(node *PorterPrivilege) porterprivilegeOption {
	return func(m *PorterPrivilegeMutation) {
		m.oldValue = func(context.Context) (*PorterPrivilege, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterPrivilegeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterPrivilegeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterPrivilegeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterPrivilegeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterPrivilege.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PorterPrivilegeMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PorterPrivilegeMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *PorterPrivilegeMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PorterPrivilegeMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PorterPrivilegeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPorterID sets the "porter_id" field.
func (m *PorterPrivilegeMutation) SetPorterID(mi model.InternalID) {
	m.porter_id = &mi
	m.addporter_id = nil
}

// PorterID returns the value of the "porter_id" field in the mutation.
func (m *PorterPrivilegeMutation) PorterID() (r model.InternalID, exists bool) {
	v := m.porter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPorterID returns the old "porter_id" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldPorterID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPorterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPorterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorterID: %w", err)
	}
	return oldValue.PorterID, nil
}

// AddPorterID adds mi to the "porter_id" field.
func (m *PorterPrivilegeMutation) AddPorterID(mi model.InternalID) {
	if m.addporter_id != nil {
		*m.addporter_id += mi
	} else {
		m.addporter_id = &mi
	}
}

// AddedPorterID returns the value that was added to the "porter_id" field in this mutation.
func (m *PorterPrivilegeMutation) AddedPorterID() (r model.InternalID, exists bool) {
	v := m.addporter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPorterID resets all changes to the "porter_id" field.
func (m *PorterPrivilegeMutation) ResetPorterID() {
	m.porter_id = nil
	m.addporter_id = nil
}

// SetPrivilege sets the "privilege" field.
func (m *PorterPrivilegeMutation) SetPrivilege(mip *modeltiphereth.PorterInstancePrivilege) {
	m.privilege = &mip
}

// Privilege returns the value of the "privilege" field in the mutation.
func (m *PorterPrivilegeMutation) Privilege() (r *modeltiphereth.PorterInstancePrivilege, exists bool) {
	v := m.privilege
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivilege returns the old "privilege" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldPrivilege(ctx context.Context) (v *modeltiphereth.PorterInstancePrivilege, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivilege is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivilege requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivilege: %w", err)
	}
	return oldValue.Privilege, nil
}

// ResetPrivilege resets all changes to the "privilege" field.
func (m *PorterPrivilegeMutation) ResetPrivilege() {
	m.privilege = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterPrivilegeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterPrivilegeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterPrivilegeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterPrivilegeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterPrivilegeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterPrivilegeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the PorterPrivilegeMutation builder.
func (m *PorterPrivilegeMutation) Where(ps ...predicate.PorterPrivilege) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterPrivilegeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterPrivilegeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterPrivilege, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterPrivilegeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterPrivilegeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterPrivilege).
func (m *PorterPrivilegeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterPrivilegeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, porterprivilege.FieldUserID)
	}
	if m.porter_id != nil {
		fields = append(fields, porterprivilege.FieldPorterID)
	}
	if m.privilege != nil {
		fields = append(fields, porterprivilege.FieldPrivilege)
	}
	if m.updated_at != nil {
		fields = append(fields, porterprivilege.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, porterprivilege.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterPrivilegeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.UserID()
	case porterprivilege.FieldPorterID:
		return m.PorterID()
	case porterprivilege.FieldPrivilege:
		return m.Privilege()
	case porterprivilege.FieldUpdatedAt:
		return m.UpdatedAt()
	case porterprivilege.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterPrivilegeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.OldUserID(ctx)
	case porterprivilege.FieldPorterID:
		return m.OldPorterID(ctx)
	case porterprivilege.FieldPrivilege:
		return m.OldPrivilege(ctx)
	case porterprivilege.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case porterprivilege.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterPrivilegeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case porterprivilege.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case porterprivilege.FieldPorterID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorterID(v)
		return nil
	case porterprivilege.FieldPrivilege:
		v, ok := value.(*modeltiphereth.PorterInstancePrivilege)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivilege(v)
		return nil
	case porterprivilege.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case porterprivilege.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterPrivilegeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, porterprivilege.FieldUserID)
	}
	if m.addporter_id != nil {
		fields = append(fields, porterprivilege.FieldPorterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterPrivilegeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.AddedUserID()
	case porterprivilege.FieldPorterID:
		return m.AddedPorterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterPrivilegeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case porterprivilege.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case porterprivilege.FieldPorterID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPorterID(v)
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterPrivilegeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterPrivilegeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterPrivilegeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterPrivilege nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterPrivilegeMutation) ResetField(name string) error {
	switch name {
	case porterprivilege.FieldUserID:
		m.ResetUserID()
		return nil
	case porterprivilege.FieldPorterID:
		m.ResetPorterID()
		return nil
	case porterprivilege.FieldPrivilege:
		m.ResetPrivilege()
		return nil
	case porterprivilege.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case porterprivilege.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterPrivilegeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterPrivilegeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterPrivilegeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterPrivilegeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterPrivilegeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterPrivilegeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterPrivilegeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PorterPrivilege unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterPrivilegeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PorterPrivilege edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	username             *string
	password             *string
	status               *user.Status
	_type                *user.Type
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	bind_account         map[model.InternalID]struct{}
	removedbind_account  map[model.InternalID]struct{}
	clearedbind_account  bool
	purchased_app        map[model.InternalID]struct{}
	removedpurchased_app map[model.InternalID]struct{}
	clearedpurchased_app bool
	app_package          map[model.InternalID]struct{}
	removedapp_package   map[model.InternalID]struct{}
	clearedapp_package   bool
	feed_config          map[model.InternalID]struct{}
	removedfeed_config   map[model.InternalID]struct{}
	clearedfeed_config   bool
	notify_target        map[model.InternalID]struct{}
	removednotify_target map[model.InternalID]struct{}
	clearednotify_target bool
	notify_flow          map[model.InternalID]struct{}
	removednotify_flow   map[model.InternalID]struct{}
	clearednotify_flow   bool
	image                map[model.InternalID]struct{}
	removedimage         map[model.InternalID]struct{}
	clearedimage         bool
	file                 map[model.InternalID]struct{}
	removedfile          map[model.InternalID]struct{}
	clearedfile          bool
	device_info          map[model.InternalID]struct{}
	removeddevice_info   map[model.InternalID]struct{}
	cleareddevice_info   bool
	creator              *model.InternalID
	clearedcreator       bool
	created_user         map[model.InternalID]struct{}
	removedcreated_user  map[model.InternalID]struct{}
	clearedcreated_user  bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id model.InternalID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(u user.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r user.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v user.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddBindAccountIDs adds the "bind_account" edge to the Account entity by ids.
func (m *UserMutation) AddBindAccountIDs(ids ...model.InternalID) {
	if m.bind_account == nil {
		m.bind_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.bind_account[ids[i]] = struct{}{}
	}
}

// ClearBindAccount clears the "bind_account" edge to the Account entity.
func (m *UserMutation) ClearBindAccount() {
	m.clearedbind_account = true
}

// BindAccountCleared reports if the "bind_account" edge to the Account entity was cleared.
func (m *UserMutation) BindAccountCleared() bool {
	return m.clearedbind_account
}

// RemoveBindAccountIDs removes the "bind_account" edge to the Account entity by IDs.
func (m *UserMutation) RemoveBindAccountIDs(ids ...model.InternalID) {
	if m.removedbind_account == nil {
		m.removedbind_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.bind_account, ids[i])
		m.removedbind_account[ids[i]] = struct{}{}
	}
}

// RemovedBindAccount returns the removed IDs of the "bind_account" edge to the Account entity.
func (m *UserMutation) RemovedBindAccountIDs() (ids []model.InternalID) {
	for id := range m.removedbind_account {
		ids = append(ids, id)
	}
	return
}

// BindAccountIDs returns the "bind_account" edge IDs in the mutation.
func (m *UserMutation) BindAccountIDs() (ids []model.InternalID) {
	for id := range m.bind_account {
		ids = append(ids, id)
	}
	return
}

// ResetBindAccount resets all changes to the "bind_account" edge.
func (m *UserMutation) ResetBindAccount() {
	m.bind_account = nil
	m.clearedbind_account = false
	m.removedbind_account = nil
}

// AddPurchasedAppIDs adds the "purchased_app" edge to the App entity by ids.
func (m *UserMutation) AddPurchasedAppIDs(ids ...model.InternalID) {
	if m.purchased_app == nil {
		m.purchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_app[ids[i]] = struct{}{}
	}
}

// ClearPurchasedApp clears the "purchased_app" edge to the App entity.
func (m *UserMutation) ClearPurchasedApp() {
	m.clearedpurchased_app = true
}

// PurchasedAppCleared reports if the "purchased_app" edge to the App entity was cleared.
func (m *UserMutation) PurchasedAppCleared() bool {
	return m.clearedpurchased_app
}

// RemovePurchasedAppIDs removes the "purchased_app" edge to the App entity by IDs.
func (m *UserMutation) RemovePurchasedAppIDs(ids ...model.InternalID) {
	if m.removedpurchased_app == nil {
		m.removedpurchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_app, ids[i])
		m.removedpurchased_app[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedApp returns the removed IDs of the "purchased_app" edge to the App entity.
func (m *UserMutation) RemovedPurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_app {
		ids = append(ids, id)
	}
	return
}

// PurchasedAppIDs returns the "purchased_app" edge IDs in the mutation.
func (m *UserMutation) PurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.purchased_app {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedApp resets all changes to the "purchased_app" edge.
func (m *UserMutation) ResetPurchasedApp() {
	m.purchased_app = nil
	m.clearedpurchased_app = false
	m.removedpurchased_app = nil
}

// AddAppPackageIDs adds the "app_package" edge to the AppPackage entity by ids.
func (m *UserMutation) AddAppPackageIDs(ids ...model.InternalID) {
	if m.app_package == nil {
		m.app_package = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_package[ids[i]] = struct{}{}
	}
}

// ClearAppPackage clears the "app_package" edge to the AppPackage entity.
func (m *UserMutation) ClearAppPackage() {
	m.clearedapp_package = true
}

// AppPackageCleared reports if the "app_package" edge to the AppPackage entity was cleared.
func (m *UserMutation) AppPackageCleared() bool {
	return m.clearedapp_package
}

// RemoveAppPackageIDs removes the "app_package" edge to the AppPackage entity by IDs.
func (m *UserMutation) RemoveAppPackageIDs(ids ...model.InternalID) {
	if m.removedapp_package == nil {
		m.removedapp_package = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_package, ids[i])
		m.removedapp_package[ids[i]] = struct{}{}
	}
}

// RemovedAppPackage returns the removed IDs of the "app_package" edge to the AppPackage entity.
func (m *UserMutation) RemovedAppPackageIDs() (ids []model.InternalID) {
	for id := range m.removedapp_package {
		ids = append(ids, id)
	}
	return
}

// AppPackageIDs returns the "app_package" edge IDs in the mutation.
func (m *UserMutation) AppPackageIDs() (ids []model.InternalID) {
	for id := range m.app_package {
		ids = append(ids, id)
	}
	return
}

// ResetAppPackage resets all changes to the "app_package" edge.
func (m *UserMutation) ResetAppPackage() {
	m.app_package = nil
	m.clearedapp_package = false
	m.removedapp_package = nil
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *UserMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *UserMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *UserMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *UserMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *UserMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *UserMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *UserMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *UserMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *UserMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *UserMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *UserMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *UserMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *UserMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *UserMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *UserMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...model.InternalID) {
	if m.image == nil {
		m.image = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *UserMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *UserMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...model.InternalID) {
	if m.removedimage == nil {
		m.removedimage = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *UserMutation) RemovedImageIDs() (ids []model.InternalID) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *UserMutation) ImageIDs() (ids []model.InternalID) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *UserMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddFileIDs adds the "file" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...model.InternalID) {
	if m.file == nil {
		m.file = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.file[ids[i]] = struct{}{}
	}
}

// ClearFile clears the "file" edge to the File entity.
func (m *UserMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *UserMutation) FileCleared() bool {
	return m.clearedfile
}

// RemoveFileIDs removes the "file" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...model.InternalID) {
	if m.removedfile == nil {
		m.removedfile = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.file, ids[i])
		m.removedfile[ids[i]] = struct{}{}
	}
}

// RemovedFile returns the removed IDs of the "file" edge to the File entity.
func (m *UserMutation) RemovedFileIDs() (ids []model.InternalID) {
	for id := range m.removedfile {
		ids = append(ids, id)
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
func (m *UserMutation) FileIDs() (ids []model.InternalID) {
	for id := range m.file {
		ids = append(ids, id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *UserMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
	m.removedfile = nil
}

// AddDeviceInfoIDs adds the "device_info" edge to the DeviceInfo entity by ids.
func (m *UserMutation) AddDeviceInfoIDs(ids ...model.InternalID) {
	if m.device_info == nil {
		m.device_info = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.device_info[ids[i]] = struct{}{}
	}
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UserMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UserMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// RemoveDeviceInfoIDs removes the "device_info" edge to the DeviceInfo entity by IDs.
func (m *UserMutation) RemoveDeviceInfoIDs(ids ...model.InternalID) {
	if m.removeddevice_info == nil {
		m.removeddevice_info = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.device_info, ids[i])
		m.removeddevice_info[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInfo returns the removed IDs of the "device_info" edge to the DeviceInfo entity.
func (m *UserMutation) RemovedDeviceInfoIDs() (ids []model.InternalID) {
	for id := range m.removeddevice_info {
		ids = append(ids, id)
	}
	return
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
func (m *UserMutation) DeviceInfoIDs() (ids []model.InternalID) {
	for id := range m.device_info {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UserMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
	m.removeddevice_info = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *UserMutation) SetCreatorID(id model.InternalID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *UserMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *UserMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *UserMutation) CreatorID() (id model.InternalID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatorIDs() (ids []model.InternalID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *UserMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddCreatedUserIDs adds the "created_user" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...model.InternalID) {
	if m.created_user == nil {
		m.created_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.created_user[ids[i]] = struct{}{}
	}
}

// ClearCreatedUser clears the "created_user" edge to the User entity.
func (m *UserMutation) ClearCreatedUser() {
	m.clearedcreated_user = true
}

// CreatedUserCleared reports if the "created_user" edge to the User entity was cleared.
func (m *UserMutation) CreatedUserCleared() bool {
	return m.clearedcreated_user
}

// RemoveCreatedUserIDs removes the "created_user" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...model.InternalID) {
	if m.removedcreated_user == nil {
		m.removedcreated_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.created_user, ids[i])
		m.removedcreated_user[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUser returns the removed IDs of the "created_user" edge to the User entity.
func (m *UserMutation) RemovedCreatedUserIDs() (ids []model.InternalID) {
	for id := range m.removedcreated_user {
		ids = append(ids, id)
	}
	return
}

// CreatedUserIDs returns the "created_user" edge IDs in the mutation.
func (m *UserMutation) CreatedUserIDs() (ids []model.InternalID) {
	for id := range m.created_user {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUser resets all changes to the "created_user" edge.
func (m *UserMutation) ResetCreatedUser() {
	m.created_user = nil
	m.clearedcreated_user = false
	m.removedcreated_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldStatus:
		return m.Status()
	case user.FieldType:
		return m.GetType()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldType:
		v, ok := value.(user.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.bind_account != nil {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.purchased_app != nil {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.app_package != nil {
		edges = append(edges, user.EdgeAppPackage)
	}
	if m.feed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.notify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.notify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.image != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.file != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.device_info != nil {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.creator != nil {
		edges = append(edges, user.EdgeCreator)
	}
	if m.created_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindAccount:
		ids := make([]ent.Value, 0, len(m.bind_account))
		for id := range m.bind_account {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.purchased_app))
		for id := range m.purchased_app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppPackage:
		ids := make([]ent.Value, 0, len(m.app_package))
		for id := range m.app_package {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.file))
		for id := range m.file {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceInfo:
		ids := make([]ent.Value, 0, len(m.device_info))
		for id := range m.device_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.created_user))
		for id := range m.created_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedbind_account != nil {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.removedpurchased_app != nil {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.removedapp_package != nil {
		edges = append(edges, user.EdgeAppPackage)
	}
	if m.removedfeed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.removednotify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.removednotify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.removedimage != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.removedfile != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.removeddevice_info != nil {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.removedcreated_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindAccount:
		ids := make([]ent.Value, 0, len(m.removedbind_account))
		for id := range m.removedbind_account {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.removedpurchased_app))
		for id := range m.removedpurchased_app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppPackage:
		ids := make([]ent.Value, 0, len(m.removedapp_package))
		for id := range m.removedapp_package {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.removedfile))
		for id := range m.removedfile {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceInfo:
		ids := make([]ent.Value, 0, len(m.removeddevice_info))
		for id := range m.removeddevice_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.removedcreated_user))
		for id := range m.removedcreated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedbind_account {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.clearedpurchased_app {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.clearedapp_package {
		edges = append(edges, user.EdgeAppPackage)
	}
	if m.clearedfeed_config {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.clearednotify_target {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.clearednotify_flow {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.clearedimage {
		edges = append(edges, user.EdgeImage)
	}
	if m.clearedfile {
		edges = append(edges, user.EdgeFile)
	}
	if m.cleareddevice_info {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.clearedcreator {
		edges = append(edges, user.EdgeCreator)
	}
	if m.clearedcreated_user {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBindAccount:
		return m.clearedbind_account
	case user.EdgePurchasedApp:
		return m.clearedpurchased_app
	case user.EdgeAppPackage:
		return m.clearedapp_package
	case user.EdgeFeedConfig:
		return m.clearedfeed_config
	case user.EdgeNotifyTarget:
		return m.clearednotify_target
	case user.EdgeNotifyFlow:
		return m.clearednotify_flow
	case user.EdgeImage:
		return m.clearedimage
	case user.EdgeFile:
		return m.clearedfile
	case user.EdgeDeviceInfo:
		return m.cleareddevice_info
	case user.EdgeCreator:
		return m.clearedcreator
	case user.EdgeCreatedUser:
		return m.clearedcreated_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBindAccount:
		m.ResetBindAccount()
		return nil
	case user.EdgePurchasedApp:
		m.ResetPurchasedApp()
		return nil
	case user.EdgeAppPackage:
		m.ResetAppPackage()
		return nil
	case user.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case user.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case user.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case user.EdgeImage:
		m.ResetImage()
		return nil
	case user.EdgeFile:
		m.ResetFile()
		return nil
	case user.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case user.EdgeCreator:
		m.ResetCreator()
		return nil
	case user.EdgeCreatedUser:
		m.ResetCreatedUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *model.InternalID
	user_id            *model.InternalID
	adduser_id         *model.InternalID
	refresh_token      *string
	expire_at          *time.Time
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	device_info        *model.InternalID
	cleareddevice_info bool
	done               bool
	oldValue           func(context.Context) (*UserSession, error)
	predicates         []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id model.InternalID) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserSessionMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSessionMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *UserSessionMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserSessionMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSessionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *UserSessionMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *UserSessionMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *UserSessionMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *UserSessionMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *UserSessionMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *UserSessionMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceInfoID sets the "device_info" edge to the DeviceInfo entity by id.
func (m *UserSessionMutation) SetDeviceInfoID(id model.InternalID) {
	m.device_info = &id
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UserSessionMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UserSessionMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoID returns the "device_info" edge ID in the mutation.
func (m *UserSessionMutation) DeviceInfoID() (id model.InternalID, exists bool) {
	if m.device_info != nil {
		return *m.device_info, true
	}
	return
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) DeviceInfoIDs() (ids []model.InternalID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UserSessionMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	if m.refresh_token != nil {
		fields = append(fields, usersession.FieldRefreshToken)
	}
	if m.expire_at != nil {
		fields = append(fields, usersession.FieldExpireAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldUserID:
		return m.UserID()
	case usersession.FieldRefreshToken:
		return m.RefreshToken()
	case usersession.FieldExpireAt:
		return m.ExpireAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldUserID:
		return m.OldUserID(ctx)
	case usersession.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case usersession.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersession.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case usersession.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldUserID:
		m.ResetUserID()
		return nil
	case usersession.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case usersession.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device_info != nil {
		edges = append(edges, usersession.EdgeDeviceInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice_info {
		edges = append(edges, usersession.EdgeDeviceInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeDeviceInfo:
		return m.cleareddevice_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}
